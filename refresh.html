<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>策略看板</title>

  <style>
    :root {
      --maxw: 1200px;
      --bg: #ffffff;
      --fg: #0f172a;
      --muted: #64748b;
      --card: #ffffff;
      --card-border: #e5e7eb;
      --accent: #0ea5e9;
      --thead: #f6f8fa;
      --row-alt: #fafafa;
      --hover: #f1f5f9;
      --ok-bg: #e6ffed; --ok-bd: #86efac;
      --err-bg: #ffe6e6; --err-bd: #f5c2c7;
    }
    body.dark {
      --bg: #0b1220;
      --fg: #e5e7eb;
      --muted: #94a3b8;
      --card: #121a2b;
      --card-border: #1f2a44;
      --accent: #38bdf8;
      --thead: #101828;
      --row-alt: #0f172a;
      --hover: #0b3753;
    }

    html, body { height: 100%; }
    body {
      margin: 0; padding: 24px;
      background: var(--bg); color: var(--fg);
      font-family: ui-sans-serif, system-ui, "Segoe UI", -apple-system, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei";
    }
    .wrap { max-width: var(--maxw); margin: 0 auto; }

    .topbar { display:flex; align-items:center; justify-content:space-between; gap:16px; margin-bottom:12px; }
    .title { font-size: 22px; font-weight: 700; letter-spacing: 0.2px; }
    .toolbar { display:flex; align-items:center; gap:8px; flex-wrap: wrap; }
    .btn, select {
      padding:8px 10px; border:1px solid var(--card-border); border-radius: 8px;
      background: var(--card); color: var(--fg); cursor: pointer;
    }
    .btn.small { font-size: 12px; padding:6px 8px; }
    .btn:hover { filter: brightness(1.05); }
    .chip {
      display:inline-block; padding: 4px 10px; border-radius: 9999px; border:1px solid var(--card-border);
      font-size: 12px; line-height: 1.2; background: var(--card);
    }
    #status { background: var(--err-bg); border-color: var(--err-bd); }
    #status.ok { background: var(--ok-bg); border-color: var(--ok-bd); }
    #lastRefresh { color: var(--muted); font-size: 12px; }

    .card {
      border:1px solid var(--card-border); border-radius: 12px; background: var(--card);
      padding: 14px; margin: 12px 0 20px;
    }
    .card-head { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:8px; }
    .card-title { font-weight:600; }
    #tv_chart { width: 100%; height: 420px; }

    table { border-collapse: collapse; width: 100%; }
    thead th { position: sticky; top: 0; background: var(--thead); z-index: 1; color: var(--fg); }
    th, td { border: 1px solid var(--card-border); padding: 10px; text-align: center; }
    /* [FIX] 原本的 nth-child 選到子元素，這裡直接套 tr 本身 */
    tbody tr.data-row:nth-of-type(odd) td { background: var(--row-alt); }
    tbody tr.data-row:hover td { background: var(--hover); }
    td.num { text-align: right; font-variant-numeric: tabular-nums; }

    /* [FIX] 圖表行的顯示與邊框：預設整行隱藏；展開時只保留頂部邊框，去掉左右邊框以免直線滲入上一行格子 */
    tr.chart-row { display: none; }
    tr.chart-row.open { display: table-row; }
    tr.chart-row > td {
      background: var(--card);
      border-top: 1px solid var(--card-border);
      border-bottom: 0;
      border-left: 0;   /* 關鍵：去掉左右邊框，避免「直線」出現在上一行某欄位內 */
      border-right: 0;  /* 關鍵 */
      padding-top: 6px;
    }

    .badge { display:inline-block; padding: 2px 8px; border-radius: 9999px; font-size: 12px; line-height: 1.6; border: 1px solid var(--card-border); }
    .badge.live { background: #e6ffed; border-color: #86efac; }
    .badge.paper { background: #e0f2fe; border-color: #93c5fd; }
    .badge.backtest { background: #fff7ed; border-color: #fdba74; }
    body.dark .badge.live { background:#0f3b2a; border-color:#16a4a4; }
    body.dark .badge.paper { background:#0e1f33; border-color:#60a5fa; }
    body.dark .badge.backtest { background:#3a2a10; border-color:#fb923c; }

    .pct.pos { color: #10b981; }
    .pct.neg { color: #ef4444; }
    .muted { color: var(--muted); }

    .chart-wrap { padding: 8px 6px; }
    .chart-title { text-align:left; font-weight:600; margin-bottom:8px; }
    .chart-meta { text-align:left; font-size:12px; color: var(--muted); margin-bottom:6px; }
    .chart-canvas { width:100%; height:320px; }
  </style>

  <script src="https://s3.tradingview.com/tv.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="title">策略看板</div>
      <div class="toolbar">
        <span id="status" class="chip" aria-live="polite">初始化</span>
        <span id="lastRefresh" class="chip">—</span>
        <button id="themeToggle" class="btn" type="button" title="切換明/暗">切換深色</button>
      </div>
    </div>

    <div class="card" aria-label="TradingView ETH K線">
      <div class="card-head">
        <div class="card-title">ETH/USDT K 線（TradingView）</div>
        <div class="toolbar">
          <label for="tv_tf">時間週期：</label>
          <select id="tv_tf" title="選擇時間週期">
            <option value="1">1m</option>
            <option value="5">5m</option>
            <option value="15" selected>15m</option>
            <option value="60">1h</option>
            <option value="240">4h</option>
            <option value="D">1d</option>
          </select>
        </div>
      </div>
      <div id="tv_chart"></div>
    </div>

    <div class="card">
      <div class="card-head">
        <div class="card-title">策略列表</div>
        <div class="muted">資料來源：Upstash（自動探索 board:*）</div>
      </div>
      <table aria-label="策略清單">
        <thead>
          <tr>
            <th style="width:140px;">名稱</th>
            <th>策略</th>
            <th>標的</th>
            <th>運行模式</th>
            <th>交易所</th>
            <th>環境</th>
            <th>7天收益率</th>
            <th>30天收益率</th>
            <th>總收益率</th>
            <th>估算年化</th>
            <th>最大回撤</th>
            <th>起始時間</th>
            <th>更新時間</th>
            <th style="width:110px;">回測圖表</th>
          </tr>
        </thead>
        <tbody id="tb">
          <tr><td class="muted" colspan="14">資料載入中…</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <script>
    let tvWidget = null;

    (function setupTheme() {
      const btn = document.getElementById('themeToggle');
      function applyTheme(theme) {
        const isDark = theme === 'dark';
        document.body.classList.toggle('dark', isDark);
        btn.textContent = isDark ? '切換淺色' : '切換深色';
        if (typeof window.__rerenderOpenCharts === 'function') window.__rerenderOpenCharts();
        recreateTVWidget();
      }
      btn.addEventListener('click', () => {
        const next = document.body.classList.contains('dark') ? 'light' : 'dark';
        applyTheme(next);
      });
      applyTheme('light');
      window.__applyTheme = applyTheme;
    })();

    function recreateTVWidget() {
      const container = document.getElementById('tv_chart');
      if (!window.TradingView || !container) return;
      container.innerHTML = '';
      tvWidget = new TradingView.widget({
        container_id: 'tv_chart',
        autosize: true,
        symbol: 'BINANCE:ETHUSDT',
        interval: document.getElementById('tv_tf')?.value || '15',
        timezone: 'Asia/Taipei',
        locale: 'zh_TW',
        theme: document.body.classList.contains('dark') ? 'dark' : 'light',
        style: '1',
        withdateranges: true,
        hide_top_toolbar: false,
        hide_side_toolbar: false,
        allow_symbol_change: false,
        details: true,
        enable_publishing: false
      });
    }

    window.addEventListener('DOMContentLoaded', function () {
      if (!window.TradingView) { console.error('[TradingView] Script 未載入'); return; }
      recreateTVWidget();
      const tfSel = document.getElementById('tv_tf');
      tfSel.addEventListener('change', function () {
        const val = tfSel.value;
        tvWidget && tvWidget.onChartReady(function () {
          tvWidget.chart().setResolution(val, function(){});
        });
      });
      if (typeof window.__applyTheme === 'function') {
        const current = document.body.classList.contains('dark') ? 'dark' : 'light';
        window.__applyTheme(current);
      }
    });

    const REST_URL    = "https://guided-spider-19708.upstash.io";
    const READ_TOKEN  = "Akz8AAIgcDE18SAeYebRfjHOi1t_RtbOFNv2r3NHF0kLYfDIUMnEOw";
    const INTERVAL_MS = 600000;

    const tb = document.getElementById("tb");
    const statusEl = document.getElementById("status");
    const lastRefreshEl = document.getElementById("lastRefresh");

    const chartInstances = new Map();
    const chartSeriesCache = new Map();

    function setStatus(ok, text) {
      statusEl.className = ok ? "chip ok" : "chip";
      statusEl.textContent = text;
    }
    function fmtPercentNode(x) {
      const span = document.createElement("span");
      const n = Number(x);
      if (!isFinite(n)) { span.className = "pct"; span.textContent = "-"; return span; }
      const val = n * 100;
      span.textContent = val.toFixed(2) + "%";
      span.className = val > 0 ? "pct pos" : (val < 0 ? "pct neg" : "pct");
      return span;
    }
    function textNode(s) { const span = document.createElement("span"); span.textContent = (s ?? "-"); return span; }
    function fmtISOToTPE(iso) {
      if (typeof iso !== "string" || !iso) return "-";
      const d = new Date(iso);
      if (isNaN(d.getTime())) return iso;
      const f = new Intl.DateTimeFormat("zh-Hant", {
        timeZone: "Asia/Taipei",
        year: "numeric", month: "2-digit", day: "2-digit",
        hour: "2-digit", minute: "2-digit"
      });
      return f.format(d);
    }
    function decodeVenue(venueStr) {
      if (typeof venueStr !== "string" || !venueStr) return { exchange: "-", env: "-" };
      const [exchange, envRaw] = venueStr.split(".");
      const env = (envRaw || "mainnet").toLowerCase();
      const envLabel = env === "testnet" ? "測試網" : "主網";
      return { exchange: exchange || "-", env: envLabel };
    }
    function modeBadge(mode) {
      const m = String(mode || "").toLowerCase();
      const map = { live: "實盤", paper: "模擬", backtest: "回測" };
      const span = document.createElement("span");
      span.className = "badge " + (m || "default");
      span.textContent = map[m] || m || "-";
      return span;
    }
    function tdNode(child, className) {
      const td = document.createElement("td");
      if (className) td.className = className;
      td.appendChild(child);
      return td;
    }

    async function upstashGet(pathWithArgs) {
      const url = `${REST_URL}/${pathWithArgs}`;
      const res = await fetch(url, { headers: { "Authorization": `Bearer ${READ_TOKEN}` }, cache: "no-store" });
      if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
      return res.json();
    }

    async function scanBoardKeys(match = "board:*", pageCount = 200) {
      let cursor = "0";
      const all = [];
      do {
        const j = await upstashGet(`scan/${cursor}?MATCH=${encodeURIComponent(match)}&COUNT=${pageCount}`);
        if (!j || !Array.isArray(j.result) || j.result.length !== 2) throw new Error("SCAN 回傳格式異常");
        cursor = String(j.result[0]);
        const batch = j.result[1];
        if (Array.isArray(batch)) for (const k of batch) if (typeof k === "string") all.push(k);
      } while (cursor !== "0");
      return all;
    }

    async function fetchKeyJSON(key) {
      const j = await upstashGet(`get/${encodeURIComponent(key)}`);
      if (!j || typeof j.result !== "string") throw new Error("GET 回傳格式異常");
      let row; try { row = JSON.parse(j.result); } catch { throw new Error("JSON 解析失敗"); }
      if (typeof row !== "object" || !row) throw new Error("資料內容不正確");
      return row;
    }

    async function fetchSeriesJSON(seriesKey) {
      const j = await upstashGet(`get/${encodeURIComponent(seriesKey)}`);
      if (!j || typeof j.result !== "string") throw new Error("GET 回傳格式異常");
      let arr; try { arr = JSON.parse(j.result); } catch { throw new Error("JSON 解析失敗"); }
      if (!Array.isArray(arr)) throw new Error("序列資料型態錯誤");
      return arr;
    }

    async function resolveSeriesForBoard(boardKey, rowObj) {
      if (rowObj && typeof rowObj.series_key === "string" && rowObj.series_key) {
        return { key: rowObj.series_key, available: true, data: await fetchSeriesJSON(rowObj.series_key) };
      }
      const custom = String(boardKey).slice("board:".length);
      const candidates = [`series:${custom}:equity`, `series:${custom}:equity30d`];
      for (const sKey of candidates) {
        try {
          const data = await fetchSeriesJSON(sKey);
          return { key: sKey, available: true, data };
        } catch (_) {}
      }
      return { key: `series:${custom}:equity`, available: false, data: [] };
    }

    function renderChartInto(boardKey, canvas, series) {
      const ctx = canvas.getContext("2d");
      const isDark = document.body.classList.contains('dark');

      if (chartInstances.has(boardKey)) {
        chartInstances.get(boardKey).destroy();
        chartInstances.delete(boardKey);
      }
      if (!Array.isArray(series) || series.length === 0) return;

      // 動態判斷 eth_close / btc_close
      const sample = series.find(x => x && typeof x === "object") || {};
      const hasEth = Object.prototype.hasOwnProperty.call(sample, "eth_close");
      const hasBtc = Object.prototype.hasOwnProperty.call(sample, "btc_close");
      const priceKey = hasEth ? "eth_close" : (hasBtc ? "btc_close" : null);
      const assetLabel = priceKey === "btc_close" ? "BTC" : "ETH";

      const labels = series.map(x => String(x.date));
      const equity  = series.map(x => Number(x.equity));
      const price   = priceKey ? series.map(x => Number(x[priceKey])) : [];

      const chart = new Chart(ctx, {
        type: "line",
        data: {
          labels,
          datasets: [
            { label: "Equity", data: equity, yAxisID: "yEquity", tension: 0.25, pointRadius: 0, borderWidth: 2 },
            { label: assetLabel + " Close", data: price, yAxisID: "yPrice", tension: 0.25, pointRadius: 0, borderWidth: 2 }
          ]
        },
        options: {
          responsive: true,
          interaction: { mode: "index", intersect: false },
          plugins: {
            legend: { display: true, labels: { color: isDark ? "#e5e7eb" : "#0f172a" } },
            tooltip: {
              callbacks: {
                label: function(ctx) {
                  const ds = ctx.dataset.label || "";
                  const v = ctx.parsed.y;
                  return ds + ": " + (typeof v === "number" ? v.toLocaleString() : v);
                }
              }
            }
          },
          scales: {
            x: {
              ticks: { color: isDark ? "#cbd5e1" : "#334155", maxRotation: 0, autoSkip: true, maxTicksLimit: 10 },
              grid:  { color: isDark ? "rgba(148,163,184,0.2)" : "rgba(148,163,184,0.2)" }
            },
            yEquity: {
              type: "linear", position: "left",
              title: { display: true, text: "Equity", color: isDark ? "#e5e7eb" : "#0f172a" },
              ticks: { color: isDark ? "#cbd5e1" : "#334155" },
              grid:  { color: isDark ? "rgba(148,163,184,0.2)" : "rgba(148,163,184,0.2)" }
            },
            yPrice: {
              type: "linear", position: "right",
              title: { display: true, text: assetLabel, color: isDark ? "#e5e7eb" : "#0f172a" },
              ticks: { color: isDark ? "#cbd5e1" : "#334155" },
              grid:  { drawOnChartArea: false, color: isDark ? "rgba(148,163,184,0.2)" : "rgba(148,163,184,0.2)" }
            }
          }
        }
      });
      chartInstances.set(boardKey, chart);

      const wrap = canvas.closest(".chart-wrap");
      if (wrap) {
        const titleEl = wrap.querySelector(".chart-title");
        const metaEl  = wrap.querySelector(".chart-meta");
        if (titleEl) titleEl.textContent = titleEl.textContent.replace(/資金曲線與.*收盤/, `資金曲線與 ${assetLabel} 收盤`);
        if (metaEl) {
          const old = metaEl.textContent || "";
          const info = priceKey ? `（price: ${priceKey}）` : `（price: 無對應欄位）`;
          if (!/（price:/.test(old)) metaEl.textContent = `${old} ${info}`.trim();
        }
      }
    }

    window.__rerenderOpenCharts = function() {
      for (const [boardKey] of chartInstances.entries()) {
        const canvas = document.getElementById(`canvas-${boardKey.replace(":","-")}`);
        if (!canvas) continue;
        const tr = canvas.closest('tr.chart-row');
        if (!tr || !tr.classList.contains('open')) continue;
        const series = chartSeriesCache.get(boardKey) || [];
        renderChartInto(boardKey, canvas, series);
      }
    };

    function renderTable(rowsByKey, seriesKeyByBoard, sortedBoardKeys) {
      tb.innerHTML = "";
      if (!sortedBoardKeys || sortedBoardKeys.length === 0) {
        const tr = document.createElement("tr");
        tr.className = "data-row";
        const td = document.createElement("td");
        td.colSpan = 14; td.className = "muted"; td.textContent = "目前未發現可用的策略資料（board:*）。";
        tr.appendChild(td); tb.appendChild(tr);
        return;
      }

      for (const key of sortedBoardKeys) {
        const row = rowsByKey.get(key);
        if (!row) continue;
        const { exchange, env } = decodeVenue(row.venue);

        const tr = document.createElement("tr"); tr.className = "data-row";
        tr.appendChild(tdNode(textNode(row.name || key)));
        tr.appendChild(tdNode(textNode(row.strategy)));
        tr.appendChild(tdNode(textNode(row.symbol)));
        tr.appendChild(tdNode(modeBadge(row.run_mode)));
        tr.appendChild(tdNode(textNode(exchange)));
        tr.appendChild(tdNode(textNode(env)));
        tr.appendChild(tdNode(fmtPercentNode(row.return_7d), "num"));
        tr.appendChild(tdNode(fmtPercentNode(row.return_30d), "num"));
        tr.appendChild(tdNode(fmtPercentNode(row.return_total), "num"));
        tr.appendChild(tdNode(fmtPercentNode(row.annualized_return), "num"));
        tr.appendChild(tdNode(fmtPercentNode(row.max_drawdown), "num"));
        tr.appendChild(tdNode(textNode(fmtISOToTPE(row.started_at))));
        tr.appendChild(tdNode(textNode(fmtISOToTPE(row.updated_at))));

        const tdBtn = document.createElement("td");
        const sKey = seriesKeyByBoard.get(key);
        if (sKey) {
          const btn = document.createElement("button");
          btn.className = "btn small";
          btn.textContent = "查看曲線";
          btn.addEventListener("click", () => toggleChartRow(key));
          tdBtn.appendChild(btn);
        } else {
          tdBtn.appendChild(textNode("—"));
        }
        tr.appendChild(tdBtn);
        tb.appendChild(tr);

        if (sKey) {
          const trChart = document.createElement("tr");
          trChart.className = "chart-row"; // [FIX] 預設 display:none，由 CSS 控制
          trChart.id = `chartrow-${key.replace(":","-")}`;
          const tdChart = document.createElement("td");
          tdChart.colSpan = 14;

          const wrap = document.createElement("div");
          wrap.className = "chart-wrap";

          const title = document.createElement("div");
          title.className = "chart-title";
          title.textContent = `${row.name || key} — 資金曲線與 收盤`;

          const meta = document.createElement("div");
          meta.className = "chart-meta";
          meta.textContent = `series: ${sKey}`;

          const canvas = document.createElement("canvas");
          canvas.className = "chart-canvas";
          canvas.id = `canvas-${key.replace(":","-")}`;

          wrap.appendChild(title);
          wrap.appendChild(meta);
          wrap.appendChild(canvas);
          tdChart.appendChild(wrap);
          trChart.appendChild(tdChart);
          tb.appendChild(trChart);
        }
      }
    }

    // [FIX] 切換整行顯示狀態，只給頂部邊框，避免「直線」入侵上一行格子
    function toggleChartRow(boardKey) {
      const rowId = boardKey.replace(":","-");
      const chartTr = document.getElementById(`chartrow-${rowId}`);
      if (!chartTr) return;

      if (chartTr.classList.contains('open')) {
        chartTr.classList.remove('open');
        return;
      }

      chartTr.classList.add('open');
      const canvas = chartTr.querySelector("canvas");
      const series = chartSeriesCache.get(boardKey) || [];
      renderChartInto(boardKey, canvas, series);
    }

    async function pullAll() {
      try {
        setStatus(false, "資料同步中…");

        const boardKeys = await scanBoardKeys("board:*", 200);

        const rowsByKey = new Map();
        const discovered = [];
        for (const k of boardKeys) {
          try {
            const row = await fetchKeyJSON(k);
            rowsByKey.set(k, row);
            const name = (row && row.name) ? String(row.name) : "";
            const updated = (row && row.updated_at) ? Date.parse(row.updated_at) : 0;
            discovered.push({ key: k, name, updated });
          } catch (e) {
            console.warn("[board 讀取失敗]", k, e);
          }
        }

        discovered.sort((a,b) => {
          if (!!a.name !== !!b.name) return b.name ? 1 : -1;
          if (a.updated !== b.updated) return b.updated - a.updated;
          return a.key.localeCompare(b.key);
        });
        const sortedBoardKeys = discovered.map(x => x.key);

        const seriesKeyByBoard = new Map();
        for (const k of sortedBoardKeys) {
          const row = rowsByKey.get(k);
          if (!row) continue;
          try {
            const { key: sKey, available, data } = await resolveSeriesForBoard(k, row);
            if (available) {
              seriesKeyByBoard.set(k, sKey);
              chartSeriesCache.set(k, data);
            }
          } catch (e) {
            console.warn("[series 探測失敗：視為無]", k, e);
          }
        }

        renderTable(rowsByKey, seriesKeyByBoard, sortedBoardKeys);

        setStatus(true, "服務正常");
        lastRefreshEl.textContent = "最後更新：" + new Date().toLocaleString("zh-TW", { hour12:false });

      } catch (e) {
        console.error(e);
        setStatus(false, "資料讀取失敗");
        tb.innerHTML = "";
        const tr = document.createElement("tr");
        tr.className = "data-row";
        const td = document.createElement("td");
        td.colSpan = 14; td.className = "muted";
        td.textContent = "目前無法取得資料，請稍後重新整理或檢查網路／權限設定。";
        tr.appendChild(td); tb.appendChild(tr);
      }
    }

    pullAll();
    setInterval(pullAll, INTERVAL_MS);
  </script>
</body>
</html>
