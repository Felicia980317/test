<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>策略看板</title>

  <style>
    :root {
      --maxw: 1600px;
      --bg: #f3f4f6;
      --fg: #0f172a;
      --muted: #6b7280;
      --card: #ffffff;
      --card-border: #e5e7eb;
      --accent: #0ea5e9;
      --accent-soft: #e0f2fe;
      --thead: #f9fafb;
      --row-alt: #f9fafb;
      --hover: #eff6ff;
      --ok-bg: #ecfdf3;
      --ok-bd: #22c55e;
      --err-bg: #fef2f2;
      --err-bd: #f97373;
    }
    body.dark {
      --bg: #020617;
      --fg: #e5e7eb;
      --muted: #94a3b8;
      --card: #020617;
      --card-border: #1f2937;
      --accent: #38bdf8;
      --accent-soft: #0f172a;
      --thead: #020617;
      --row-alt: #020617;
      --hover: #111827;
    }

    html, body { height: 100%; }

    body {
      margin: 0;
      padding: 24px 32px 32px;
      background:
        radial-gradient(circle at 0% 0%, #e0f2fe 0, #f9fafb 35%, #f3f4f6 100%);
      color: var(--fg);
      font-family: ui-sans-serif, system-ui, "Segoe UI", -apple-system,
        "Noto Sans TC", "PingFang TC", "Microsoft JhengHei";
    }
    body.dark {
      background:
        radial-gradient(circle at 0% 0%, #0b1120 0, #020617 45%, #020617 100%);
    }

    .wrap {
      max-width: var(--maxw);
      margin: 0 auto;
    }

    .topbar {
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 18px;
    }
    .title {
      font-size: 26px;
      font-weight: 700;
      letter-spacing: 0.04em;
      display: flex;
      align-items: baseline;
      gap: 10px;
    }
    .title span.sub {
      font-size: 12px;
      font-weight: 500;
      color: var(--muted);
      padding: 2px 8px;
      border-radius: 9999px;
      background: var(--accent-soft);
    }
    body.dark .title span.sub {
      background: #0b1120;
      color: #9ca3af;
    }

    .toolbar {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .btn,
    select {
      padding: 8px 12px;
      border-radius: 9999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      background: #0f172a;
      color: #f9fafb;
      cursor: pointer;
      font-size: 12px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      line-height: 1.2;
      transition: background 0.15s ease, box-shadow 0.15s ease, transform 0.05s ease;
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.18);
    }
    .btn.small {
      font-size: 11px;
      padding: 6px 10px;
      box-shadow: none;
    }
    .btn:hover:enabled {
      transform: translateY(-1px);
      box-shadow: 0 12px 26px rgba(15, 23, 42, 0.25);
      filter: brightness(1.05);
    }
    .btn:active:enabled {
      transform: translateY(0);
      box-shadow: 0 4px 10px rgba(15, 23, 42, 0.15);
    }
    .btn:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
      transform: none;
    }
    select {
      background: var(--card);
      color: var(--fg);
      box-shadow: none;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 9999px;
      border: 1px solid var(--card-border);
      font-size: 11px;
      line-height: 1.2;
      background: var(--card);
      color: var(--muted);
    }
    #status {
      background: var(--err-bg);
      border-color: var(--err-bd);
      color: #b91c1c;
      font-weight: 500;
    }
    #status::before {
      content: "";
      width: 8px;
      height: 8px;
      border-radius: 9999px;
      background: #ef4444;
      box-shadow: 0 0 0 3px rgba(248, 113, 113, 0.2);
    }
    #status.ok {
      background: var(--ok-bg);
      border-color: var(--ok-bd);
      color: #15803d;
    }
    #status.ok::before {
      background: #22c55e;
      box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.2);
    }
    #lastRefresh {
      color: var(--muted);
      font-size: 11px;
    }

    .card {
      border-radius: 16px;
      background: var(--card);
      border: 1px solid rgba(148, 163, 184, 0.25);
      box-shadow:
        0 20px 45px rgba(15, 23, 42, 0.08),
        0 1px 0 rgba(255, 255, 255, 0.6);
      padding: 16px 18px 18px;
      margin: 12px 0 20px;
    }
    body.dark .card {
      box-shadow: 0 18px 36px rgba(0, 0, 0, 0.6);
    }

    .card-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.3);
    }
    .card-title {
      font-weight: 600;
      letter-spacing: 0.03em;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .card-title::before {
      content: "";
      width: 6px;
      height: 20px;
      border-radius: 9999px;
      background: linear-gradient(180deg, #0ea5e9, #22c55e);
    }

    #tv_chart {
      width: 100%;
      height: 420px;
      border-radius: 12px;
      overflow: hidden;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      border-radius: 12px;
      overflow: hidden;
      background: var(--card);
    }

    thead th {
      position: sticky;
      top: 0;
      z-index: 1;
      background: var(--thead);
      color: var(--muted);
      font-size: 13px;             /* 表頭字體加大 */
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      padding: 12px 10px;
      border-bottom: 1px solid var(--card-border);
    }

    th, td {
      border: 1px solid var(--card-border);
      padding: 9px 10px;
      text-align: center;
      font-size: 13px;
    }

    /* 左靠欄位（名稱／策略／標的） */
    tbody td:first-child,
    tbody td:nth-child(2),
    tbody td:nth-child(3) {
      text-align: left;
    }

    td.num {
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    /* 一般列交錯底色 + hover */
    tbody tr.data-row:nth-of-type(odd) td {
      background: var(--row-alt);
    }
    tbody tr.data-row:hover td {
      background: var(--hover);
    }

    /* 不活躍列：整列灰底（展開時用） */
    tbody tr.data-row.row-stale td {
      background: #f3f4f6;
    }
    tbody tr.data-row.row-stale:hover td {
      background: #e5e7eb;
    }
    body.dark tbody tr.data-row.row-stale td {
      background: #111827;
    }
    body.dark tbody tr.data-row.row-stale:hover td {
      background: #020617;
    }

    /* 回測圖表列顯示控制 */
    tr.chart-row { display: none; }
    tr.chart-row.open { display: table-row; }
    tr.chart-row > td {
      background: var(--card);
      border-top: 1px solid var(--card-border);
      border-bottom: 0;
      border-left: 0;
      border-right: 0;
      padding-top: 6px;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 2px 10px;
      border-radius: 9999px;
      font-size: 11px;
      line-height: 1.6;
      border: 1px solid var(--card-border);
      background: #f9fafb;
      color: #0f172a;
    }
    .badge.live {
      background: #ecfdf3;
      border-color: #4ade80;
      color: #166534;
    }
    .badge.paper {
      background: #eff6ff;
      border-color: #93c5fd;
      color: #1d4ed8;
    }
    .badge.backtest {
      background: #fff7ed;
      border-color: #fdba74;
      color: #9a3412;
    }
    body.dark .badge.live {
      background: #052e16;
      border-color: #22c55e;
      color: #bbf7d0;
    }
    body.dark .badge.paper {
      background: #0b1120;
      border-color: #60a5fa;
      color: #bfdbfe;
    }
    body.dark .badge.backtest {
      background: #3a2a10;
      border-color: #fb923c;
      color: #fed7aa;
    }

    .pct.pos { color: #16a34a; }
    .pct.neg { color: #ef4444; }
    .muted { color: var(--muted); }
    .dir-long {
      color: #22c55e;
      font-weight: 600;
    }
    .dir-short {
      color: #ef4444;
      font-weight: 600;
    }
    body.dark .dir-long {
      color: #4ade80;
    }
    body.dark .dir-short {
      color: #fca5a5;
    }

    /* 更新時間顏色差異（7 天內 / 7 天以上） */
    .updated-active { color: #16a34a; font-weight: 500; }
    .updated-stale  { color: #f97316; }
    body.dark .updated-active { color: #4ade80; }
    body.dark .updated-stale  { color: #fdba74; }

    /* 不活躍標籤 */
    .inactive-pill {
      display: inline-flex;
      align-items: center;
      padding: 0 6px;
      border-radius: 9999px;
      border: 1px solid #d1d5db;
      font-size: 10px;
      margin-left: 4px;
      color: #6b7280;
      background: #f9fafb;
    }
    body.dark .inactive-pill {
      border-color: #374151;
      background: #020617;
      color: #9ca3af;
    }

    .chart-wrap {
      padding: 8px 4px 4px;
    }
    .chart-title {
      text-align: left;
      font-weight: 600;
      margin-bottom: 6px;
      font-size: 13px;
    }
    .chart-meta {
      text-align: left;
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    .chart-canvas {
      width: 100%;
      height: 320px;
    }
  </style>

  <script src="https://s3.tradingview.com/tv.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        策略看板
        <span class="sub">ETH 量化策略監控</span>
      </div>
      <div class="toolbar">
        <span id="status" class="chip" aria-live="polite">初始化</span>
        <span id="lastRefresh" class="chip">—</span>
        <button id="themeToggle" class="btn" type="button" title="切換明/暗">切換淺色</button>
      </div>
    </div>

    <div class="card" aria-label="TradingView ETH K線">
      <div class="card-head">
        <div class="card-title">ETH/USDT K 線（TradingView）</div>
        <div class="toolbar">
          <label for="tv_tf">時間週期：</label>
          <select id="tv_tf" title="選擇時間週期">
            <option value="1">1m</option>
            <option value="5">5m</option>
            <option value="15" selected>15m</option>
            <option value="60">1h</option>
            <option value="240">4h</option>
            <option value="D">1d</option>
          </select>
        </div>
      </div>
      <div id="tv_chart"></div>
    </div>

    <div class="card">
      <div class="card-head">
        <div class="card-title">策略列表</div>
        <div class="toolbar">
          <span class="muted">資料來源：Upstash（自動探索 board:*）</span>
          <button id="toggleInactive" class="btn small" type="button" disabled>
            無不活躍策略
          </button>
        </div>
      </div>
      <table aria-label="策略清單">
        <thead>
          <tr>
            <th style="width:160px;">名稱</th>
            <th>策略</th>
            <th>標的</th>
            <th>運行模式</th>
            <th>交易所</th>
            <th>槓桿</th>
            <th>方向</th>
            <th>7天收益率</th>
            <th>30天收益率</th>
            <th>線性年化報酬率<br>(依據總收益)</th>
            <th>最大回撤</th>
            <th>起始時間</th>
            <th>更新時間</th>
            <th style="width:110px;">回測圖表</th>
          </tr>
        </thead>
        <tbody id="tb">
          <tr><td class="muted" colspan="14">資料載入中…</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <script>
    let tvWidget = null;

    (function setupTheme() {
      const btn = document.getElementById('themeToggle');
      function applyTheme(theme) {
        const isDark = theme === 'dark';
        document.body.classList.toggle('dark', isDark);
        btn.textContent = isDark ? '切換淺色' : '切換深色';
        if (typeof window.__rerenderOpenCharts === 'function') window.__rerenderOpenCharts();
        recreateTVWidget();
      }
      btn.addEventListener('click', () => {
        const next = document.body.classList.contains('dark') ? 'light' : 'dark';
        applyTheme(next);
      });
      // 預設深色主題
      applyTheme('dark');
      window.__applyTheme = applyTheme;
    })();

    function recreateTVWidget() {
      const container = document.getElementById('tv_chart');
      if (!window.TradingView || !container) return;
      container.innerHTML = '';
      tvWidget = new TradingView.widget({
        container_id: 'tv_chart',
        autosize: true,
        symbol: 'BINANCE:ETHUSDT',
        interval: document.getElementById('tv_tf')?.value || '15',
        timezone: 'Asia/Taipei',
        locale: 'zh_TW',
        theme: document.body.classList.contains('dark') ? 'dark' : 'light',
        style: '1',
        withdateranges: true,
        hide_top_toolbar: false,
        hide_side_toolbar: false,
        allow_symbol_change: false,
        details: true,
        enable_publishing: false
      });
    }

    window.addEventListener('DOMContentLoaded', function () {
      if (!window.TradingView) { console.error('[TradingView] Script 未載入'); return; }
      recreateTVWidget();
      const tfSel = document.getElementById('tv_tf');
      tfSel.addEventListener('change', function () {
        const val = tfSel.value;
        tvWidget && tvWidget.onChartReady(function () {
          tvWidget.chart().setResolution(val, function(){});
        });
      });
      if (typeof window.__applyTheme === 'function') {
        const current = document.body.classList.contains('dark') ? 'dark' : 'light';
        window.__applyTheme(current);
      }
    });

    const REST_URL    = "https://guided-spider-19708.upstash.io";
    const READ_TOKEN  = "Akz8AAIgcDE18SAeYebRfjHOi1t_RtbOFNv2r3NHF0kLYfDIUMnEOw";
    const INTERVAL_MS = 600000;

    const tb = document.getElementById("tb");
    const statusEl = document.getElementById("status");
    const lastRefreshEl = document.getElementById("lastRefresh");
    const inactiveToggleBtn = document.getElementById("toggleInactive");

    const chartInstances = new Map();
    const chartSeriesCache = new Map();
    let showInactive = true;

    function setStatus(ok, text) {
      statusEl.className = ok ? "chip ok" : "chip";
      statusEl.textContent = text;
    }

    function fmtPercentNode(x) {
      const span = document.createElement("span");
      const n = Number(x);
      if (!isFinite(n)) { span.className = "pct"; span.textContent = "-"; return span; }
      const val = n * 100;
      span.textContent = val.toFixed(2) + "%";
      span.className = val > 0 ? "pct pos" : (val < 0 ? "pct neg" : "pct");
      return span;
    }

    function fmtPercentText(x) {
      const n = Number(x);
      if (!isFinite(n)) return "-";
      const val = n * 100;
      return val.toFixed(2) + "%";
    }

    function textNode(s) {
      const span = document.createElement("span");
      span.textContent = (s ?? "-");
      return span;
    }

    function fmtISOToTPE(iso) {
      if (typeof iso !== "string" || !iso) return "-";
      const d = new Date(iso);
      if (isNaN(d.getTime())) return iso;
      const f = new Intl.DateTimeFormat("zh-Hant", {
        timeZone: "Asia/Taipei",
        year: "numeric", month: "2-digit", day: "2-digit",
        hour: "2-digit", minute: "2-digit",
        hour12: false
      });
      return f.format(d);
    }

    function fmtISOToTPEDate(iso) {
      if (typeof iso !== "string" || !iso) return "-";
      const d = new Date(iso);
      if (isNaN(d.getTime())) return iso;
      const f = new Intl.DateTimeFormat("zh-Hant", {
        timeZone: "Asia/Taipei",
        year: "numeric", month: "2-digit", day: "2-digit"
      });
      return f.format(d);
    }

    function isRecentUpdate(iso) {
      if (typeof iso !== "string" || !iso) return false;
      const d = new Date(iso);
      if (isNaN(d.getTime())) return false;
      const diff = Date.now() - d.getTime();
      const sevenDaysMs = 7 * 24 * 60 * 60 * 1000;
      return diff <= sevenDaysMs;
    }

    function decodeVenue(venueStr) {
      if (typeof venueStr !== "string" || !venueStr) return { exchange: "-", env: "-" };
      const [exchange, envRaw] = venueStr.split(".");
      const env = (envRaw || "mainnet").toLowerCase();
      const envLabel = env === "testnet" ? "測試網" : "主網";
      return { exchange: exchange || "-", env: envLabel };
    }

    function fmtLeverage(val) {
      if (val === null || val === undefined || val === "") return "-";
      const n = Number(val);
      if (!isFinite(n)) return "-";
      return String(Math.round(n));
    }

    function fmtDirection(dir) {
      const s = String(dir || "").toLowerCase();
      if (!s) return "-";
      if (s === "long") return "Long";
      if (s === "short") return "Short";
      return dir;
    }
    function modeBadge(mode) {
      const m = String(mode || "").toLowerCase();
      const map = {
        live: "個人實盤",
        "server.live": "伺服實盤",
        paper: "模擬",
        backtest: "回測"
      };
      const span = document.createElement("span");
      let cls = m || "default";
      if (m === "server.live") cls = "live";
      span.className = "badge " + cls;
      span.textContent = map[m] || m || "-";
      return span;
    }

    function tdNode(child, className) {
      const td = document.createElement("td");
      if (className) td.className = className;
      td.appendChild(child);
      return td;
    }

    async function upstashGet(pathWithArgs) {
      const url = `${REST_URL}/${pathWithArgs}`;
      const res = await fetch(url, {
        headers: { "Authorization": `Bearer ${READ_TOKEN}` },
        cache: "no-store"
      });
      if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
      return res.json();
    }

    async function scanBoardKeys(match = "board:*", pageCount = 200) {
      let cursor = "0";
      const all = [];
      do {
        const j = await upstashGet(
          `scan/${cursor}?MATCH=${encodeURIComponent(match)}&COUNT=${pageCount}`
        );
        if (!j || !Array.isArray(j.result) || j.result.length !== 2) {
          throw new Error("SCAN 回傳格式異常");
        }
        cursor = String(j.result[0]);
        const batch = j.result[1];
        if (Array.isArray(batch)) {
          for (const k of batch) if (typeof k === "string") all.push(k);
        }
      } while (cursor !== "0");
      return all;
    }

    async function fetchKeyJSON(key) {
      const j = await upstashGet(`get/${encodeURIComponent(key)}`);
      if (!j || typeof j.result !== "string") throw new Error("GET 回傳格式異常");
      let row;
      try {
        row = JSON.parse(j.result);
      } catch {
        throw new Error("JSON 解析失敗");
      }
      if (typeof row !== "object" || !row) throw new Error("資料內容不正確");
      return row;
    }

    async function fetchSeriesJSON(seriesKey) {
      const j = await upstashGet(`get/${encodeURIComponent(seriesKey)}`);
      if (!j || typeof j.result !== "string") throw new Error("GET 回傳格式異常");
      let arr;
      try {
        arr = JSON.parse(j.result);
      } catch {
        throw new Error("JSON 解析失敗");
      }
      if (!Array.isArray(arr)) throw new Error("序列資料型態錯誤");
      return arr;
    }

    async function resolveSeriesForBoard(boardKey, rowObj) {
      if (rowObj && typeof rowObj.series_key === "string" && rowObj.series_key) {
        return {
          key: rowObj.series_key,
          available: true,
          data: await fetchSeriesJSON(rowObj.series_key)
        };
      }
      const custom = String(boardKey).slice("board:".length);
      const candidates = [`series:${custom}:equity`, `series:${custom}:equity30d`];
      for (const sKey of candidates) {
        try {
          const data = await fetchSeriesJSON(sKey);
          return { key: sKey, available: true, data };
        } catch (_) {}
      }
      return { key: `series:${custom}:equity`, available: false, data: [] };
    }

    function renderChartInto(boardKey, canvas, series) {
      const ctx = canvas.getContext("2d");
      const isDark = document.body.classList.contains('dark');

      if (chartInstances.has(boardKey)) {
        chartInstances.get(boardKey).destroy();
        chartInstances.delete(boardKey);
      }
      if (!Array.isArray(series) || series.length === 0) return;

      const sample = series.find(x => x && typeof x === "object") || {};
      const hasEth = Object.prototype.hasOwnProperty.call(sample, "eth_close");
      const hasBtc = Object.prototype.hasOwnProperty.call(sample, "btc_close");
      const priceKey = hasEth ? "eth_close" : (hasBtc ? "btc_close" : null);
      const assetLabel = priceKey === "btc_close" ? "BTC" : "ETH";

      const labels = series.map(x => String(x.date));
      const equity  = series.map(x => Number(x.equity));
      const price   = priceKey ? series.map(x => Number(x[priceKey])) : [];

      const chart = new Chart(ctx, {
        type: "line",
        data: {
          labels,
          datasets: [
            {
              label: "Equity",
              data: equity,
              yAxisID: "yEquity",
              tension: 0.25,
              pointRadius: 0,
              borderWidth: 2
            },
            {
              label: assetLabel + " Close",
              data: price,
              yAxisID: "yPrice",
              tension: 0.25,
              pointRadius: 0,
              borderWidth: 2
            }
          ]
        },
        options: {
          responsive: true,
          interaction: { mode: "index", intersect: false },
          plugins: {
            legend: {
              display: true,
              labels: { color: isDark ? "#e5e7eb" : "#0f172a" }
            },
            tooltip: {
              callbacks: {
                label: function(ctx) {
                  const ds = ctx.dataset.label || "";
                  const v = ctx.parsed.y;
                  return ds + ": " + (typeof v === "number" ? v.toLocaleString() : v);
                }
              }
            }
          },
          scales: {
            x: {
              ticks: {
                color: isDark ? "#cbd5e1" : "#334155",
                maxRotation: 0,
                autoSkip: true,
                maxTicksLimit: 10
              },
              grid: {
                color: isDark
                  ? "rgba(148,163,184,0.2)"
                  : "rgba(148,163,184,0.2)"
              }
            },
            yEquity: {
              type: "linear",
              position: "left",
              title: {
                display: true,
                text: "Equity",
                color: isDark ? "#e5e7eb" : "#0f172a"
              },
              ticks: { color: isDark ? "#cbd5e1" : "#334155" },
              grid: {
                color: isDark
                  ? "rgba(148,163,184,0.2)"
                  : "rgba(148,163,184,0.2)"
              }
            },
            yPrice: {
              type: "linear",
              position: "right",
              title: {
                display: true,
                text: assetLabel,
                color: isDark ? "#e5e7eb" : "#0f172a"
              },
              ticks: { color: isDark ? "#cbd5e1" : "#334155" },
              grid: {
                drawOnChartArea: false,
                color: isDark
                  ? "rgba(148,163,184,0.2)"
                  : "rgba(148,163,184,0.2)"
              }
            }
          }
        }
      });
      chartInstances.set(boardKey, chart);

      const wrap = canvas.closest(".chart-wrap");
      if (wrap) {
        const titleEl = wrap.querySelector(".chart-title");
        const metaEl  = wrap.querySelector(".chart-meta");
        if (titleEl) {
          titleEl.textContent = titleEl.textContent.replace(
            /資金曲線與.*收盤/,
            `資金曲線與 ${assetLabel} 收盤`
          );
        }
        if (metaEl) {
          const old = metaEl.textContent || "";
          const info = priceKey
            ? `（price: ${priceKey}）`
            : `（price: 無對應欄位）`;
          if (!/（price:/.test(old)) metaEl.textContent = `${old} ${info}`.trim();
        }
      }
    }

    window.__rerenderOpenCharts = function() {
      for (const [boardKey] of chartInstances.entries()) {
        const canvas = document.getElementById(`canvas-${boardKey.replace(":","-")}`);
        if (!canvas) continue;
        const tr = canvas.closest('tr.chart-row');
        if (!tr || !tr.classList.contains('open')) continue;
        const series = chartSeriesCache.get(boardKey) || [];
        renderChartInto(boardKey, canvas, series);
      }
    };

    function updateInactiveToggleLabel(count) {
      if (!inactiveToggleBtn) return;
      inactiveToggleBtn.dataset.inactiveCount = String(count);
      if (count === 0) {
        inactiveToggleBtn.textContent = "無不活躍策略";
        inactiveToggleBtn.disabled = true;
        return;
      }
      inactiveToggleBtn.disabled = false;
      inactiveToggleBtn.textContent = showInactive
        ? `隱藏不活躍策略 (${count})`
        : `顯示不活躍策略 (${count})`;
    }

    function applyInactiveVisibility() {
      const rows = tb.querySelectorAll("tr.data-row.row-stale");
      rows.forEach(tr => {
        tr.style.display = showInactive ? "" : "none";
      });
    }

    if (inactiveToggleBtn) {
      inactiveToggleBtn.addEventListener("click", () => {
        showInactive = !showInactive;
        const count = Number(inactiveToggleBtn.dataset.inactiveCount || "0");
        updateInactiveToggleLabel(count);
        applyInactiveVisibility();
      });
    }

    function renderTable(rowsByKey, seriesKeyByBoard, sortedBoardKeys) {
      tb.innerHTML = "";
      if (!sortedBoardKeys || sortedBoardKeys.length === 0) {
        const tr = document.createElement("tr");
        tr.className = "data-row";
        const td = document.createElement("td");
        td.colSpan = 14;
        td.className = "muted";
        td.textContent = "目前未發現可用的策略資料（board:*）。";
        tr.appendChild(td);
        tb.appendChild(tr);
        updateInactiveToggleLabel(0);
        return;
      }

      let inactiveCount = 0;

      for (const key of sortedBoardKeys) {
        const row = rowsByKey.get(key);
        if (!row) continue;
        const { exchange } = decodeVenue(row.venue);

        const tr = document.createElement("tr");
        tr.className = "data-row";

        tr.appendChild(tdNode(textNode(row.name || key)));
        tr.appendChild(tdNode(textNode(row.strategy)));
        tr.appendChild(tdNode(textNode(row.symbol)));
        tr.appendChild(tdNode(modeBadge(row.run_mode)));
        tr.appendChild(tdNode(textNode(exchange)));
        tr.appendChild(tdNode(textNode(fmtLeverage(row.leverage)), "num"));
        const dirText = fmtDirection(row.direction);
        const dirSpan = document.createElement("span");
        dirSpan.textContent = dirText;

        if (dirText === "Long") {
          dirSpan.className = "dir-long";
        } else if (dirText === "Short") {
          dirSpan.className = "dir-short";
        }

        tr.appendChild(tdNode(dirSpan));
        tr.appendChild(tdNode(fmtPercentNode(row.return_7d), "num"));
        tr.appendChild(tdNode(fmtPercentNode(row.return_30d), "num"));

        const annualTd = tdNode(fmtPercentNode(row.annualized_return), "num");
        const totalText = fmtPercentText(row.return_total);
        annualTd.title = totalText === "-"
          ? "總收益率：資料缺失"
          : `總收益率：${totalText}`;
        tr.appendChild(annualTd);

        tr.appendChild(tdNode(fmtPercentNode(row.max_drawdown), "num"));
        tr.appendChild(tdNode(textNode(fmtISOToTPEDate(row.started_at))));

        const updatedStr = fmtISOToTPE(row.updated_at);
        const updatedSpan = document.createElement("span");
        updatedSpan.textContent = updatedStr;
        const recent = isRecentUpdate(row.updated_at);
        updatedSpan.className = recent ? "updated-active" : "updated-stale";
        updatedSpan.title = recent
          ? "最近 7 天內有更新（視為活躍策略）"
          : "已超過 7 天未更新（視為不活躍策略）";

        const updatedTd = document.createElement("td");
        updatedTd.appendChild(updatedSpan);

        if (!recent) {
          const pill = document.createElement("span");
          pill.className = "inactive-pill";
          pill.textContent = "不活躍";
          updatedTd.appendChild(document.createTextNode(" "));
          updatedTd.appendChild(pill);
          tr.classList.add("row-stale");
          inactiveCount++;
        }

        tr.appendChild(updatedTd);

        const tdBtn = document.createElement("td");
        const sKey = seriesKeyByBoard.get(key);
        if (sKey) {
          const btn = document.createElement("button");
          btn.className = "btn small";
          btn.textContent = "查看曲線";
          btn.addEventListener("click", () => toggleChartRow(key));
          tdBtn.appendChild(btn);
        } else {
          tdBtn.appendChild(textNode("—"));
        }
        tr.appendChild(tdBtn);
        tb.appendChild(tr);

        if (sKey) {
          const trChart = document.createElement("tr");
          trChart.className = "chart-row";
          trChart.id = `chartrow-${key.replace(":","-")}`;
          const tdChart = document.createElement("td");
          tdChart.colSpan = 14;

          const wrap = document.createElement("div");
          wrap.className = "chart-wrap";

          const title = document.createElement("div");
          title.className = "chart-title";
          title.textContent = `${row.name || key} — 資金曲線與 收盤`;

          const meta = document.createElement("div");
          meta.className = "chart-meta";
          meta.textContent = `series: ${sKey}`;

          const canvas = document.createElement("canvas");
          canvas.className = "chart-canvas";
          canvas.id = `canvas-${key.replace(":","-")}`;

          wrap.appendChild(title);
          wrap.appendChild(meta);
          wrap.appendChild(canvas);
          tdChart.appendChild(wrap);
          trChart.appendChild(tdChart);
          tb.appendChild(trChart);
        }
      }

      updateInactiveToggleLabel(inactiveCount);
      applyInactiveVisibility();
    }

    function toggleChartRow(boardKey) {
      const rowId = boardKey.replace(":","-");
      const chartTr = document.getElementById(`chartrow-${rowId}`);
      if (!chartTr) return;

      if (chartTr.classList.contains('open')) {
        chartTr.classList.remove('open');
        return;
      }

      chartTr.classList.add('open');
      const canvas = chartTr.querySelector("canvas");
      const series = chartSeriesCache.get(boardKey) || [];
      renderChartInto(boardKey, canvas, series);
    }

    async function pullAll() {
      try {
        setStatus(false, "資料同步中…");

        const boardKeys = await scanBoardKeys("board:*", 200);

        const rowsByKey = new Map();
        const discovered = [];
        for (const k of boardKeys) {
          try {
            const row = await fetchKeyJSON(k);
            rowsByKey.set(k, row);
            const name = (row && row.name) ? String(row.name) : "";
            const updated = (row && row.updated_at)
              ? Date.parse(row.updated_at)
              : 0;
            discovered.push({ key: k, name, updated });
          } catch (e) {
            console.warn("[board 讀取失敗]", k, e);
          }
        }

        discovered.sort((a, b) => {
          if (!!a.name !== !!b.name) return b.name ? 1 : -1;
          if (a.updated !== b.updated) return b.updated - a.updated;
          return a.key.localeCompare(b.key);
        });
        const sortedBoardKeys = discovered.map(x => x.key);

        const seriesKeyByBoard = new Map();
        for (const k of sortedBoardKeys) {
          const row = rowsByKey.get(k);
          if (!row) continue;
          try {
            const { key: sKey, available, data } =
              await resolveSeriesForBoard(k, row);
            if (available) {
              seriesKeyByBoard.set(k, sKey);
              chartSeriesCache.set(k, data);
            }
          } catch (e) {
            console.warn("[series 探測失敗：視為無]", k, e);
          }
        }

        renderTable(rowsByKey, seriesKeyByBoard, sortedBoardKeys);

        setStatus(true, "服務正常");
        lastRefreshEl.textContent = "最後更新：" +
          new Date().toLocaleString("zh-TW", { hour12:false });

      } catch (e) {
        console.error(e);
        setStatus(false, "資料讀取失敗");
        tb.innerHTML = "";
        const tr = document.createElement("tr");
        tr.className = "data-row";
        const td = document.createElement("td");
        td.colSpan = 14;
        td.className = "muted";
        td.textContent = "目前無法取得資料，請稍後重新整理或檢查網路／權限設定。";
        tr.appendChild(td);
        tb.appendChild(tr);
        updateInactiveToggleLabel(0);
      }
    }

    pullAll();
    setInterval(pullAll, INTERVAL_MS);
  </script>
</body>
</html>
