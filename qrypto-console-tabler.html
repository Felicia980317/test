<!doctype html>
<html lang="zh-Hant" data-bs-theme="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Qrypto 策略中控台（Tabler）</title>

  <!-- Tabler UI (MIT). CDN CSS only; no build step. -->
  <link rel="stylesheet" href="https://unpkg.com/@tabler/core@latest/dist/css/tabler.min.css" />

  <style>
    :root {
      --panel-h: 420px;
    }
    body {
      background:
        radial-gradient(900px 520px at 15% 10%, rgba(var(--bs-primary-rgb), 0.14), transparent 62%),
        radial-gradient(780px 520px at 85% 20%, rgba(var(--bs-info-rgb), 0.12), transparent 60%),
        radial-gradient(1000px 650px at 35% 95%, rgba(var(--bs-success-rgb), 0.10), transparent 58%),
        linear-gradient(180deg, var(--bs-body-bg) 0%, var(--bs-body-bg) 100%);
    }

    /* Keep existing ids; just constrain heights */
    #tv_chart { width: 100%; height: var(--panel-h); border-radius: 12px; overflow: hidden; }
    #feedList { height: var(--panel-h); overflow: auto; }

    /* Strategy cards inside a table body */
    .table.table-vcenter {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0 12px;
    }
    thead { display: none; }
    #tb tr.data-row td { padding: 0; border: 0; }
    tr.chart-row { display: none; }
    tr.chart-row.open { display: table-row; }
    tr.chart-row > td { padding: 0 0 12px 0; border: 0; }

    .strategy-card {
      border-radius: 14px;
      border: 1px solid rgba(var(--bs-body-color-rgb), 0.12);
      background: rgba(var(--bs-body-bg-rgb), 0.70);
      backdrop-filter: blur(14px);
      padding: 14px;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 14px;
    }

    /* Make adjacent strategies more distinguishable */
    #tb tr.data-row:nth-of-type(odd) .strategy-card {
      background: rgba(var(--bs-body-bg-rgb), 0.78);
    }
    #tb tr.data-row:nth-of-type(even) .strategy-card {
      background: rgba(var(--bs-body-bg-rgb), 0.66);
    }
    .strategy-card::before {
      content: "";
      position: absolute;
      left: 0; top: 0; bottom: 0;
      width: 5px;
      background: linear-gradient(180deg, rgb(var(--bs-primary-rgb)), rgb(var(--bs-info-rgb)));
      opacity: 0.95;
    }
    .strategy-head { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
    .strategy-name { font-weight: 700; font-size: 1rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 520px; }
    .strategy-sub { margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .chip { display: inline-flex; align-items: center; gap: 6px; padding: 4px 10px; border-radius: 9999px; border: 1px solid rgba(var(--bs-body-color-rgb), 0.14); background: rgba(var(--bs-body-bg-rgb), 0.72); font-size: 12px; }

    .strategy-main { flex: 1 1 auto; min-width: 0; }
    .strategy-actions { flex: 0 0 auto; display: flex; align-items: flex-start; }
    @media (max-width: 900px) {
      .strategy-card { flex-direction: column; }
      .strategy-actions { width: 100%; justify-content: flex-end; }
    }

    .chart-card {
      border-radius: 14px;
      border: 1px solid rgba(var(--bs-body-color-rgb), 0.12);
      background: rgba(var(--bs-body-bg-rgb), 0.70);
      backdrop-filter: blur(14px);
      padding: 14px;
    }

    .kpi-grid { margin-top: 12px; display: grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 10px; }
    @media (max-width: 900px) { .kpi-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); } .strategy-name { max-width: 100%; } }

    .kpi { border-radius: 12px; border: 1px solid rgba(var(--bs-body-color-rgb), 0.12); background: rgba(var(--bs-body-bg-rgb), 0.70); padding: 10px; }
    .kpi-label { font-size: 11px; opacity: 0.75; letter-spacing: 0.08em; text-transform: uppercase; }
    .kpi-value { font-size: 18px; font-weight: 700; margin-top: 4px; }

    .pct.pos { color: var(--bs-success); }
    .pct.neg { color: var(--bs-danger); }

    .log-tags { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
    .tag { display: inline-flex; align-items: center; padding: 2px 8px; border-radius: 9999px; border: 1px solid rgba(var(--bs-body-color-rgb), 0.14); background: rgba(var(--bs-body-bg-rgb), 0.70); font-size: 12px; }

    .log-item { border-radius: 12px; border: 1px solid rgba(var(--bs-body-color-rgb), 0.12); background: rgba(var(--bs-body-bg-rgb), 0.70); padding: 10px 12px; }
    .log-time { opacity: 0.7; font-size: 12px; }
    .log-msg { margin-top: 4px; }
  </style>

  <script src="https://s3.tradingview.com/tv.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="./upstash-config.js"></script>
</head>
<body>
  <div class="page">
    <header class="navbar navbar-expand-md bg-body-tertiary border-bottom">
      <div class="container-xl">
        <a class="navbar-brand" href="#">Qrypto 策略中控台</a>
        <div class="navbar-nav flex-row ms-auto align-items-center gap-2">
          <span id="status" class="badge bg-red-lt">初始化</span>
          <span id="lastRefresh" class="text-secondary small">—</span>
          <button id="themeToggle" class="btn btn-outline-secondary btn-sm" type="button">切換淺色</button>
        </div>
      </div>
    </header>

    <div class="page-wrapper">
      <div class="container-xl">
        <div class="row row-cards mt-3">
          <div class="col-12 col-lg-8">
            <div class="card">
              <div class="card-header">
                <div class="card-title" id="tv_title">BTC/USDT K 線（TradingView）</div>
                <div class="ms-auto d-flex gap-2 align-items-center flex-wrap">
                  <label for="tv_symbol" class="form-label mb-0">幣種</label>
                  <select id="tv_symbol" class="form-select form-select-sm" style="width:auto">
                    <option value="BTC" selected>BTC</option>
                    <option value="ETH">ETH</option>
                    <option value="SOL">SOL</option>
                  </select>
                  <label for="tv_tf" class="form-label mb-0 ms-2">週期</label>
                  <select id="tv_tf" class="form-select form-select-sm" style="width:auto">
                    <option value="1">1m</option>
                    <option value="5">5m</option>
                    <option value="15" selected>15m</option>
                    <option value="60">1h</option>
                    <option value="240">4h</option>
                    <option value="D">1d</option>
                  </select>
                </div>
              </div>
              <div class="card-body p-2">
                <div id="tv_chart"></div>
              </div>
            </div>
          </div>

          <div class="col-12 col-lg-4">
            <div class="card">
              <div class="card-header">
                <div class="card-title">交易訊息</div>
                <div class="ms-auto"><span id="feedStatus" class="badge bg-secondary-lt">—</span></div>
              </div>
              <div class="card-body p-2">
                <div id="feedList" class="d-flex flex-column gap-2" role="log" aria-live="polite">
                  <div class="text-muted">載入中…</div>
                </div>
              </div>
            </div>
          </div>

          <div class="col-12">
            <div class="card">
              <div class="card-header">
                <div class="card-title">策略列表</div>
                <div class="ms-auto d-flex gap-2 align-items-center flex-wrap">
                  <label for="yearFilter" class="form-label mb-0 ms-2">年度</label>
                  <select id="yearFilter" class="form-select form-select-sm" style="width:auto">
                    <option value="">載入中…</option>
                  </select>
                  <button id="toggleInactive" class="btn btn-outline-secondary btn-sm" type="button" disabled>無不活躍策略</button>
                </div>
              </div>
              <div class="card-body">
                <div class="table-responsive">
                  <table class="table table-vcenter">
                    <tbody id="tb">
                      <tr><td class="text-muted">資料載入中…</td></tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>

        </div>
      </div>
    </div>
  </div>

  <script>
    let tvWidget = null;

    function isDarkTheme() {
      return (document.documentElement.getAttribute('data-bs-theme') || 'dark') !== 'light';
    }

    function getCurrentAssetBase() {
      const sel = document.getElementById('tv_symbol');
      const val = sel && sel.value ? sel.value.toUpperCase() : 'BTC';
      if (val !== 'BTC' && val !== 'ETH' && val !== 'SOL') return 'BTC';
      return val;
    }

    function updateSymbolTexts() {
      const base = getCurrentAssetBase();
      const titleEl = document.getElementById('tv_title');
      if (titleEl) titleEl.textContent = `${base}/USDT K 線（TradingView）`;
    }

    (function setupTheme() {
      const btn = document.getElementById('themeToggle');
      function applyTheme(theme) {
        const isDark = theme === 'dark';
        document.documentElement.setAttribute('data-bs-theme', isDark ? 'dark' : 'light');
        btn.textContent = isDark ? '切換淺色' : '切換深色';
        if (typeof window.__rerenderOpenCharts === 'function') window.__rerenderOpenCharts();
        recreateTVWidget();
      }
      btn.addEventListener('click', () => {
        const next = isDarkTheme() ? 'light' : 'dark';
        applyTheme(next);
      });
      applyTheme('dark');
      window.__applyTheme = applyTheme;
    })();

    function recreateTVWidget() {
      const container = document.getElementById('tv_chart');
      if (!window.TradingView || !container) return;

      const base = getCurrentAssetBase();
      const symbolCode = `BINANCE:${base}USDT`;

      container.innerHTML = '';
      tvWidget = new TradingView.widget({
        container_id: 'tv_chart',
        autosize: true,
        symbol: symbolCode,
        interval: document.getElementById('tv_tf')?.value || '15',
        timezone: 'Asia/Taipei',
        locale: 'zh_TW',
        theme: isDarkTheme() ? 'dark' : 'light',
        style: '1',
        withdateranges: true,
        hide_top_toolbar: false,
        hide_side_toolbar: false,
        allow_symbol_change: false,
        details: true,
        enable_publishing: false
      });
    }

    window.addEventListener('DOMContentLoaded', function () {
      if (!window.TradingView) { console.error('[TradingView] Script 未載入'); return; }
      recreateTVWidget();

      const tfSel = document.getElementById('tv_tf');
      tfSel.addEventListener('change', function () {
        const val = tfSel.value;
        tvWidget && tvWidget.onChartReady(function () {
          tvWidget.chart().setResolution(val, function(){});
        });
      });

      const symbolSel = document.getElementById('tv_symbol');
      if (symbolSel) {
        symbolSel.addEventListener('change', function () {
          recreateTVWidget();
          updateSymbolTexts();
          if (typeof window.__rerenderOpenCharts === 'function') window.__rerenderOpenCharts();
        });
      }

      if (typeof window.__applyTheme === 'function') {
        const current = isDarkTheme() ? 'dark' : 'light';
        window.__applyTheme(current);
      }

      updateSymbolTexts();
    });

    const REST_URL = window.UPSTASH_REST_URL;
    const READ_TOKEN = window.UPSTASH_READ_TOKEN;
    const INTERVAL_MS = window.QRYPTO_PULL_INTERVAL_MS ?? 600000;

    const FEED_LIST_KEY = window.QRYPTO_FEED_LIST_KEY ?? 'log:events';
    const FEED_LIMIT = window.QRYPTO_FEED_LIMIT ?? 80;
    const FEED_POLL_MS = window.QRYPTO_FEED_POLL_MS ?? 5000;

    const tb = document.getElementById('tb');
    const statusEl = document.getElementById('status');
    const lastRefreshEl = document.getElementById('lastRefresh');
    const inactiveToggleBtn = document.getElementById('toggleInactive');
    const yearFilterSel = document.getElementById('yearFilter');

    const feedListEl = document.getElementById('feedList');
    const feedStatusEl = document.getElementById('feedStatus');

    const chartInstances = new Map();
    const chartSeriesCache = new Map();
    const normalizedSeriesCache = new Map();
    const yearsByBoard = new Map();
    let allYearsSet = new Set();

    let showInactive = true;
    let yearFilterValue = null;

    let latestRowsByKey = null;
    let latestSeriesKeyByBoard = null;
    let latestSortedBoardKeys = null;

    function setStatus(ok, text) {
      statusEl.className = ok === true
        ? 'badge bg-green-lt'
        : (ok === false ? 'badge bg-red-lt' : 'badge bg-secondary-lt');
      statusEl.textContent = text;
    }

    function fmtPercentNode(x) {
      const span = document.createElement('span');
      const n = Number(x);
      if (!isFinite(n)) {
        span.textContent = '-';
        return span;
      }
      const val = n * 100;
      span.textContent = val.toFixed(2) + '%';
      span.className = val > 0 ? 'pct pos' : (val < 0 ? 'pct neg' : 'pct');
      return span;
    }

    function fmtPercentText(x) {
      const n = Number(x);
      if (!isFinite(n)) return '-';
      const val = n * 100;
      return val.toFixed(2) + '%';
    }

    function fmtISOToTPE(iso) {
      if (typeof iso !== 'string' || !iso) return '-';
      const d = new Date(iso);
      if (isNaN(d.getTime())) return iso;
      const f = new Intl.DateTimeFormat('zh-Hant', {
        timeZone: 'Asia/Taipei',
        year: 'numeric', month: '2-digit', day: '2-digit',
        hour: '2-digit', minute: '2-digit',
        hour12: false
      });
      return f.format(d);
    }

    function fmtISOToTPEDate(iso) {
      if (typeof iso !== 'string' || !iso) return '-';
      const d = new Date(iso);
      if (isNaN(d.getTime())) return iso;
      const f = new Intl.DateTimeFormat('zh-Hant', {
        timeZone: 'Asia/Taipei',
        year: 'numeric', month: '2-digit', day: '2-digit'
      });
      return f.format(d);
    }

    function isRecentUpdate(iso) {
      if (typeof iso !== 'string' || !iso) return false;
      const d = new Date(iso);
      if (isNaN(d.getTime())) return false;
      const diff = Date.now() - d.getTime();
      const sevenDaysMs = 7 * 24 * 60 * 60 * 1000;
      return diff <= sevenDaysMs;
    }

    function decodeVenue(venueStr) {
      if (typeof venueStr !== 'string' || !venueStr) return { exchange: '-', env: '-' };
      const parts = venueStr.split('.');
      const exchange = parts[0] || '-';
      const envRaw = parts[1] || 'mainnet';
      const env = envRaw.toLowerCase() === 'testnet' ? '測試網' : '主網';
      return { exchange, env };
    }

    function fmtLeverage(val) {
      if (val === null || val === undefined || val === '') return '-';
      const n = Number(val);
      if (!isFinite(n)) return '-';
      return String(Math.round(n));
    }

    function fmtDirection(dir) {
      const s = String(dir || '').toLowerCase();
      if (!s) return '-';
      if (s === 'long') return 'Long';
      if (s === 'short') return 'Short';
      return dir;
    }

    function modeBadge(mode) {
      const m = String(mode || '').toLowerCase();
      const map = {
        live: '個人實盤',
        'server.live': '伺服實盤',
        paper: '模擬',
        backtest: '回測'
      };
      const span = document.createElement('span');
      span.className = 'badge bg-indigo-lt text-indigo';
      span.textContent = map[m] || m || '-';
      return span;
    }

    async function upstashGet(pathWithArgs) {
      if (!REST_URL || !READ_TOKEN) {
        throw new Error('Upstash 設定缺失：請確認 upstash-config.js 已載入（UPSTASH_REST_URL / UPSTASH_READ_TOKEN）');
      }
      const url = `${REST_URL}/${pathWithArgs}`;
      const res = await fetch(url, {
        headers: { 'Authorization': `Bearer ${READ_TOKEN}` },
        cache: 'no-store'
      });
      if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
      return res.json();
    }

    async function upstashLRange(key, start, stop) {
      const j = await upstashGet(`lrange/${encodeURIComponent(key)}/${start}/${stop}`);
      if (!j || !Array.isArray(j.result)) throw new Error('LRANGE 回傳格式異常');
      return j.result;
    }

    function safeParseJSON(s) {
      if (typeof s !== 'string') return null;
      try { return JSON.parse(s); } catch { return null; }
    }

    function fmtFeedTime(x) {
      if (typeof x === 'number' && isFinite(x)) {
        return new Date(x).toLocaleString('zh-TW', { hour12: false });
      }
      if (typeof x === 'string' && x) return fmtISOToTPE(x);
      return '-';
    }

    function setFeedStatus(ok, text) {
      if (!feedStatusEl) return;
      feedStatusEl.className = ok === true
        ? 'badge bg-green-lt'
        : (ok === false ? 'badge bg-red-lt' : 'badge bg-secondary-lt');
      feedStatusEl.textContent = text;
    }

    function renderFeedItems(items) {
      if (!feedListEl) return;
      feedListEl.innerHTML = '';
      if (!items || items.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'text-muted';
        empty.textContent = '目前沒有訊息';
        feedListEl.appendChild(empty);
        return;
      }

      for (const it of items) {
        const obj = (typeof it === 'object' && it) ? it : { msg: String(it) };
        const when = obj.ts ?? obj.time ?? obj.at;
        const main = obj.msg ?? obj.message ?? obj.event ?? '(no message)';

        const wrap = document.createElement('div');
        wrap.className = 'log-item';

        const t = document.createElement('div');
        t.className = 'log-time';
        t.textContent = fmtFeedTime(when);

        const msg = document.createElement('div');
        msg.className = 'log-msg';
        msg.textContent = String(main);

        const tags = document.createElement('div');
        tags.className = 'log-tags';
        const tagPairs = [
          ['strategy', obj.strategy],
          ['symbol', obj.symbol],
          ['side', obj.side],
          ['price', obj.price],
          ['qty', obj.qty],
          ['level', obj.level]
        ];
        for (const [k, v] of tagPairs) {
          if (v === null || v === undefined || v === '') continue;
          const tag = document.createElement('span');
          tag.className = 'tag';
          tag.textContent = `${k}: ${v}`;
          tags.appendChild(tag);
        }

        wrap.appendChild(t);
        wrap.appendChild(msg);
        if (tags.childNodes.length) wrap.appendChild(tags);
        feedListEl.appendChild(wrap);
      }
    }

    async function pullFeed() {
      try {
        setFeedStatus(null, '訊息同步中…');
        const raw = await upstashLRange(FEED_LIST_KEY, 0, FEED_LIMIT - 1);
        const parsed = raw.map(s => safeParseJSON(s) ?? s);
        renderFeedItems(parsed);
        setFeedStatus(true, `訊息 ${parsed.length}`);
      } catch (e) {
        console.warn('[feed 讀取失敗]', e);
        if (feedListEl) {
          feedListEl.innerHTML = '';
          const div = document.createElement('div');
          div.className = 'text-muted';
          div.textContent = '訊息讀取失敗（請檢查 Upstash / 權限 / 網路）';
          feedListEl.appendChild(div);
        }
        setFeedStatus(false, '訊息失敗');
      }
    }

    async function scanBoardKeys(match = 'board:*', pageCount = 200) {
      let cursor = '0';
      const all = [];
      do {
        const j = await upstashGet(`scan/${cursor}?MATCH=${encodeURIComponent(match)}&COUNT=${pageCount}`);
        if (!j || !Array.isArray(j.result) || j.result.length !== 2) throw new Error('SCAN 回傳格式異常');
        cursor = String(j.result[0]);
        const batch = j.result[1];
        if (Array.isArray(batch)) for (const k of batch) if (typeof k === 'string') all.push(k);
      } while (cursor !== '0');
      return all;
    }

    async function fetchKeyJSON(key) {
      const j = await upstashGet(`get/${encodeURIComponent(key)}`);
      if (!j || typeof j.result !== 'string') throw new Error('GET 回傳格式異常');
      let row;
      try { row = JSON.parse(j.result); } catch { throw new Error('JSON 解析失敗'); }
      if (typeof row !== 'object' || !row) throw new Error('資料內容不正確');
      return row;
    }

    async function fetchSeriesJSON(seriesKey) {
      const j = await upstashGet(`get/${encodeURIComponent(seriesKey)}`);
      if (!j || typeof j.result !== 'string') throw new Error('GET 回傳格式異常');
      let arr;
      try { arr = JSON.parse(j.result); } catch { throw new Error('JSON 解析失敗'); }
      if (!Array.isArray(arr)) throw new Error('序列資料型態錯誤');
      return arr;
    }

    async function resolveSeriesForBoard(boardKey, rowObj) {
      if (rowObj && typeof rowObj.series_key === 'string' && rowObj.series_key) {
        return { key: rowObj.series_key, available: true, data: await fetchSeriesJSON(rowObj.series_key) };
      }
      const custom = String(boardKey).slice('board:'.length);
      const candidates = [`series:${custom}:equity`, `series:${custom}:equity30d`];
      for (const sKey of candidates) {
        try {
          const data = await fetchSeriesJSON(sKey);
          return { key: sKey, available: true, data };
        } catch (_) {}
      }
      return { key: `series:${custom}:equity`, available: false, data: [] };
    }

    function renderChartInto(boardKey, canvas, series) {
      const ctx = canvas.getContext('2d');
      const css = getComputedStyle(document.documentElement);
      const isDark = isDarkTheme();
      const colorBody = css.getPropertyValue('--bs-body-color').trim() || (isDark ? '#e5e7eb' : '#0f172a');
      const colorMuted = css.getPropertyValue('--bs-secondary-color').trim() || (isDark ? '#cbd5e1' : '#334155');
      const colorBorder = css.getPropertyValue('--bs-border-color').trim() || 'rgba(148,163,184,0.2)';
      const colorPrimary = css.getPropertyValue('--bs-primary').trim() || (isDark ? '#60a5fa' : '#2563eb');
      const colorInfo = css.getPropertyValue('--bs-info').trim() || (isDark ? '#22d3ee' : '#06b6d4');
      if (chartInstances.has(boardKey)) {
        chartInstances.get(boardKey).destroy();
        chartInstances.delete(boardKey);
      }
      if (!Array.isArray(series) || series.length === 0) return;

      const sample = series.find(x => x && typeof x === 'object') || {};
      const base = getCurrentAssetBase();
      const keyMap = { BTC: 'btc_close', ETH: 'eth_close', SOL: 'sol_close' };
      let priceKey = keyMap[base];
      if (!priceKey || !Object.prototype.hasOwnProperty.call(sample, priceKey)) {
        const hasEth = Object.prototype.hasOwnProperty.call(sample, 'eth_close');
        const hasBtc = Object.prototype.hasOwnProperty.call(sample, 'btc_close');
        const hasSol = Object.prototype.hasOwnProperty.call(sample, 'sol_close');
        if (hasBtc) priceKey = 'btc_close';
        else if (hasEth) priceKey = 'eth_close';
        else if (hasSol) priceKey = 'sol_close';
        else priceKey = null;
      }

      let assetLabel = 'Asset';
      if (priceKey === 'btc_close') assetLabel = 'BTC';
      else if (priceKey === 'eth_close') assetLabel = 'ETH';
      else if (priceKey === 'sol_close') assetLabel = 'SOL';

      const labels = series.map(x => String(x.date));
      const equity = series.map(x => Number(x.equity));
      const price = priceKey ? series.map(x => Number(x[priceKey])) : [];

      const chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets: [
            { label: 'Equity', data: equity, yAxisID: 'yEquity', tension: 0.25, pointRadius: 0, borderWidth: 2, borderColor: colorPrimary },
            { label: assetLabel + ' Close', data: price, yAxisID: 'yPrice', tension: 0.25, pointRadius: 0, borderWidth: 2, borderColor: colorInfo }
          ]
        },
        options: {
          responsive: true,
          interaction: { mode: 'index', intersect: false },
          plugins: {
            legend: {
              display: true,
              labels: { color: colorBody }
            },
            tooltip: {
              callbacks: {
                label: function(ctx) {
                  const ds = ctx.dataset.label || '';
                  const v = ctx.parsed.y;
                  return ds + ': ' + (typeof v === 'number' ? v.toLocaleString() : v);
                }
              }
            }
          },
          scales: {
            x: {
              ticks: { color: colorMuted, maxRotation: 0, autoSkip: true, maxTicksLimit: 10 },
              grid: { color: colorBorder }
            },
            yEquity: {
              type: 'linear',
              position: 'left',
              title: { display: true, text: 'Equity', color: colorBody },
              ticks: { color: colorMuted },
              grid: { color: colorBorder }
            },
            yPrice: {
              type: 'linear',
              position: 'right',
              title: { display: true, text: assetLabel, color: colorBody },
              ticks: { color: colorMuted },
              grid: { drawOnChartArea: false, color: colorBorder }
            }
          }
        }
      });
      chartInstances.set(boardKey, chart);
    }

    window.__rerenderOpenCharts = function() {
      for (const [boardKey] of chartInstances.entries()) {
        const canvas = document.getElementById(`canvas-${boardKey.replace(':','-')}`);
        if (!canvas) continue;
        const tr = canvas.closest('tr.chart-row');
        if (!tr || !tr.classList.contains('open')) continue;
        const series = chartSeriesCache.get(boardKey) || [];
        renderChartInto(boardKey, canvas, series);
      }
    };

    function updateInactiveToggleLabel(count) {
      if (!inactiveToggleBtn) return;
      inactiveToggleBtn.dataset.inactiveCount = String(count);
      if (count === 0) {
        inactiveToggleBtn.textContent = '無不活躍策略';
        inactiveToggleBtn.disabled = true;
        return;
      }
      inactiveToggleBtn.disabled = false;
      inactiveToggleBtn.textContent = showInactive
        ? `隱藏不活躍策略 (${count})`
        : `顯示不活躍策略 (${count})`;
    }

    function applyInactiveVisibility() {
      const rows = tb.querySelectorAll('tr.data-row.row-stale');
      rows.forEach(tr => { tr.style.display = showInactive ? '' : 'none'; });
    }

    if (inactiveToggleBtn) {
      inactiveToggleBtn.addEventListener('click', () => {
        showInactive = !showInactive;
        const count = Number(inactiveToggleBtn.dataset.inactiveCount || '0');
        updateInactiveToggleLabel(count);
        applyInactiveVisibility();
      });
    }

    function buildNormalizedSeries(series) {
      const arr = [];
      if (!Array.isArray(series)) return arr;
      for (const s of series) {
        if (!s) continue;
        const d = new Date(s.date);
        const t = d.getTime();
        if (!isFinite(t)) continue;
        const year = d.getFullYear();
        const eq = Number(s.equity);
        if (!isFinite(eq)) continue;
        arr.push({ t, year, equity: eq });
      }
      arr.sort((a, b) => a.t - b.t);
      return arr;
    }

    function computeYearStats(normalizedSeries, year) {
      if (!normalizedSeries || !normalizedSeries.length) return null;
      const Y = Number(year);
      if (!isFinite(Y)) return null;
      const subset = normalizedSeries.filter(p => p.year === Y);
      if (!subset.length) return null;

      const first = subset[0];
      const last = subset[subset.length - 1];
      const startEq = first.equity;
      const endEq = last.equity;
      let totalReturn = NaN;
      if (isFinite(startEq) && startEq > 0 && isFinite(endEq)) totalReturn = (endEq / startEq) - 1;

      const msDiff = last.t - first.t;
      const dayDiff = (msDiff / 86400000) + 1;
      let annualizedReturn = NaN;
      if (isFinite(totalReturn) && dayDiff > 0) annualizedReturn = totalReturn * 365 / dayDiff;

      let peak = subset[0].equity;
      let maxDD = 0;
      for (const p of subset) {
        if (p.equity > peak) peak = p.equity;
        if (peak > 0) {
          const dd = (p.equity / peak) - 1;
          if (dd < maxDD) maxDD = dd;
        }
      }

      function calcLookback(days) {
        const targetTs = last.t - days * 86400000;
        let base = null;
        for (let i = subset.length - 1; i >= 0; i--) {
          if (subset[i].t <= targetTs) { base = subset[i]; break; }
        }
        if (!base || base.equity <= 0) return (last.equity / subset[0].equity) - 1;
        return (last.equity / base.equity) - 1;
      }

      const r7 = calcLookback(7);
      const r30 = calcLookback(30);

      return {
        totalReturn,
        annualizedReturn: totalReturn < 0 ? totalReturn : annualizedReturn,
        maxDrawdown: maxDD,
        return7d: r7,
        return30d: r30
      };
    }

    function rebuildYearFilterOptions(yearsArr) {
      if (!yearFilterSel) return;
      yearFilterSel.innerHTML = '';
      if (!yearsArr || yearsArr.length === 0) {
        const op = document.createElement('option');
        op.value = '';
        op.textContent = '無資料';
        yearFilterSel.appendChild(op);
        yearFilterSel.disabled = true;
        yearFilterValue = null;
        return;
      }
      const sorted = yearsArr.slice().sort((a, b) => b - a);
      sorted.forEach(y => {
        const op = document.createElement('option');
        op.value = String(y);
        op.textContent = String(y);
        yearFilterSel.appendChild(op);
      });
      const prev = yearFilterValue ? Number(yearFilterValue) : null;
      if (!prev || !sorted.includes(prev)) yearFilterValue = String(sorted[0]);
      yearFilterSel.value = yearFilterValue;
      yearFilterSel.disabled = false;
    }

    if (yearFilterSel) {
      yearFilterSel.addEventListener('change', () => {
        yearFilterValue = yearFilterSel.value || null;
        if (latestRowsByKey && latestSeriesKeyByBoard && latestSortedBoardKeys) {
          renderTable(latestRowsByKey, latestSeriesKeyByBoard, latestSortedBoardKeys);
        }
      });
    }

    function renderTable(rowsByKey, seriesKeyByBoard, sortedBoardKeys) {
      tb.innerHTML = '';
      if (!sortedBoardKeys || sortedBoardKeys.length === 0) {
        const tr = document.createElement('tr');
        tr.className = 'data-row';
        const td = document.createElement('td');
        td.className = 'text-muted';
        td.textContent = '目前未發現可用的策略資料。';
        tr.appendChild(td);
        tb.appendChild(tr);
        updateInactiveToggleLabel(0);
        return;
      }

      let inactiveCount = 0;
      const yearNum = yearFilterValue ? Number(yearFilterValue) : null;

      for (const key of sortedBoardKeys) {
        const row = rowsByKey.get(key);
        if (!row) continue;

        const sKey = seriesKeyByBoard.get(key);
        const norm = normalizedSeriesCache.get(key) || [];
        const yearsSet = yearsByBoard.get(key);

        let yearStats = null;
        if (yearNum !== null) {
          if (!yearsSet || !yearsSet.has(yearNum)) continue;
          yearStats = computeYearStats(norm, yearNum);
        }

        const { exchange, env } = decodeVenue(row.venue);

        const tr = document.createElement('tr');
        tr.className = 'data-row';

        const recent = isRecentUpdate(row.updated_at);
        if (!recent) { tr.classList.add('row-stale', 'stale'); inactiveCount++; }

        const td = document.createElement('td');

        const card = document.createElement('div');
        card.className = 'strategy-card';

        const head = document.createElement('div');
        head.className = 'strategy-head';

        const name = document.createElement('div');
        name.className = 'strategy-name';
        name.textContent = row.name || key;
        head.appendChild(name);

        if (yearNum !== null) {
          const y = document.createElement('span');
          y.className = 'badge bg-orange-lt text-orange';
          y.textContent = `${yearNum} 統計`;
          head.appendChild(y);
        }

        head.appendChild(modeBadge(row.run_mode));

        const dirText = fmtDirection(row.direction);
        if (dirText && dirText !== '-') {
          const dir = document.createElement('span');
          dir.className = 'badge bg-azure-lt text-azure';
          dir.textContent = dirText;
          head.appendChild(dir);
        }

        const sub = document.createElement('div');
        sub.className = 'strategy-sub';

        const updated = document.createElement('span');
        updated.className = recent ? 'badge bg-green-lt text-green' : 'badge bg-orange-lt text-orange';
        updated.textContent = `更新：${fmtISOToTPE(row.updated_at)}`;
        updated.title = recent ? '最近 7 天內有更新（活躍）' : '已超過 7 天未更新（不活躍）';
        sub.appendChild(updated);

        const chips = [
          ['策略', row.strategy],
          ['標的', row.symbol],
          ['交易所', exchange],
          ['環境', env],
          ['槓桿', fmtLeverage(row.leverage)],
          ['起始', fmtISOToTPEDate(row.started_at)],
        ];
        for (const [k, v] of chips) {
          if (v === null || v === undefined || v === '' || v === '-') continue;
          const tag = document.createElement('span');
          tag.className = 'chip';
          tag.textContent = `${k}: ${v}`;
          sub.appendChild(tag);
        }

        const main = document.createElement('div');
        main.className = 'strategy-main';
        main.appendChild(head);
        main.appendChild(sub);

        const r30Val = yearStats ? yearStats.return30d : row.return_30d;
        const annVal = yearStats ? yearStats.annualizedReturn : row.annualized_return;
        const totVal = yearStats ? yearStats.totalReturn : row.return_total;
        const ddVal = yearStats ? yearStats.maxDrawdown : row.max_drawdown;

        const grid = document.createElement('div');
        grid.className = 'kpi-grid';

        function kpi(label, valueNode, title) {
          const box = document.createElement('div');
          box.className = 'kpi';
          if (title) box.title = title;
          const l = document.createElement('div');
          l.className = 'kpi-label';
          l.textContent = label;
          const v = document.createElement('div');
          v.className = 'kpi-value';
          v.appendChild(valueNode);
          box.appendChild(l);
          box.appendChild(v);
          return box;
        }

        const totalText = fmtPercentText(totVal);
        grid.appendChild(kpi('總收益', fmtPercentNode(totVal), '從起始資金到目前的總收益率'));
        grid.appendChild(kpi('30天', fmtPercentNode(r30Val), '最近 30 天的收益率'));
        const annTitle = totalText === '-' ? '年化(線性)：資料不足（會以總收益率替代顯示）' : `年化(線性)：依據總收益率 ${totalText}`;
        grid.appendChild(kpi('年化(線性)', fmtPercentNode(annVal), annTitle));
        grid.appendChild(kpi('最大回撤', fmtPercentNode(ddVal), '回測/序列期間的最大回撤'));
        main.appendChild(grid);

        const actions = document.createElement('div');
        actions.className = 'strategy-actions';
        if (sKey) {
          const btn = document.createElement('button');
          btn.className = 'btn btn-outline-primary btn-sm';
          btn.textContent = '查看曲線';
          btn.addEventListener('click', () => toggleChartRow(key));
          actions.appendChild(btn);
        } else {
          const no = document.createElement('div');
          no.className = 'text-muted';
          no.textContent = '無曲線資料';
          actions.appendChild(no);
        }

        card.appendChild(main);
        card.appendChild(actions);
        td.appendChild(card);
        tr.appendChild(td);
        tb.appendChild(tr);

        if (sKey) {
          const trChart = document.createElement('tr');
          trChart.className = 'chart-row';
          trChart.id = `chartrow-${key.replace(':','-')}`;
          const tdChart = document.createElement('td');

          const wrap = document.createElement('div');
          wrap.className = 'chart-card';

          const title = document.createElement('div');
          title.className = 'fw-bold mb-2';
          title.textContent = `${row.name || key} — 資金曲線與 收盤`;

          const canvas = document.createElement('canvas');
          canvas.style.width = '100%';
          canvas.style.height = '320px';
          canvas.id = `canvas-${key.replace(':','-')}`;

          wrap.appendChild(title);
          wrap.appendChild(canvas);

          tdChart.appendChild(wrap);
          trChart.appendChild(tdChart);
          tb.appendChild(trChart);
        }
      }

      updateInactiveToggleLabel(inactiveCount);
      applyInactiveVisibility();
    }

    function toggleChartRow(boardKey) {
      const rowId = boardKey.replace(':','-');
      const chartTr = document.getElementById(`chartrow-${rowId}`);
      if (!chartTr) return;
      if (chartTr.classList.contains('open')) {
        chartTr.classList.remove('open');
        return;
      }
      chartTr.classList.add('open');
      const canvas = chartTr.querySelector('canvas');
      const series = chartSeriesCache.get(boardKey) || [];
      renderChartInto(boardKey, canvas, series);
    }

    async function pullAll() {
      try {
        setStatus(null, '資料同步中…');
        const boardKeys = await scanBoardKeys('board:*', 200);

        const rowsByKey = new Map();
        const discovered = [];
        for (const k of boardKeys) {
          try {
            const row = await fetchKeyJSON(k);
            rowsByKey.set(k, row);
            const name = (row && row.name) ? String(row.name) : '';
            const updated = (row && row.updated_at) ? Date.parse(row.updated_at) : 0;
            discovered.push({ key: k, name, updated });
          } catch (e) {
            console.warn('[board 讀取失敗]', k, e);
          }
        }

        discovered.sort((a, b) => {
          if (!!a.name !== !!b.name) return b.name ? 1 : -1;
          if (a.updated !== b.updated) return b.updated - a.updated;
          return a.key.localeCompare(b.key);
        });
        const sortedBoardKeys = discovered.map(x => x.key);

        const seriesKeyByBoard = new Map();
        chartSeriesCache.clear();
        normalizedSeriesCache.clear();
        yearsByBoard.clear();
        allYearsSet = new Set();

        for (const k of sortedBoardKeys) {
          const row = rowsByKey.get(k);
          if (!row) continue;
          try {
            const { key: sKey, available, data } = await resolveSeriesForBoard(k, row);
            if (available) {
              seriesKeyByBoard.set(k, sKey);
              chartSeriesCache.set(k, data);

              const norm = buildNormalizedSeries(data);
              normalizedSeriesCache.set(k, norm);

              const yearSet = new Set();
              for (const p of norm) { yearSet.add(p.year); allYearsSet.add(p.year); }
              yearsByBoard.set(k, yearSet);
            }
          } catch (e) {
            console.warn('[series 探測失敗：視為無]', k, e);
          }
        }

        rebuildYearFilterOptions(Array.from(allYearsSet));

        latestRowsByKey = rowsByKey;
        latestSeriesKeyByBoard = seriesKeyByBoard;
        latestSortedBoardKeys = sortedBoardKeys;

        renderTable(rowsByKey, seriesKeyByBoard, sortedBoardKeys);

        setStatus(true, '服務正常');
        lastRefreshEl.textContent = '最後更新：' + new Date().toLocaleString('zh-TW', { hour12: false });
      } catch (e) {
        console.error(e);
        setStatus(false, '資料讀取失敗');
        tb.innerHTML = '<tr><td class="text-muted">目前無法取得資料，請稍後重新整理或檢查網路／權限設定。</td></tr>';
        updateInactiveToggleLabel(0);
      }
    }

    pullAll();
    setInterval(pullAll, INTERVAL_MS);

    pullFeed();
    setInterval(pullFeed, FEED_POLL_MS);
  </script>
</body>
</html>
