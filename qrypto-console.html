<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Qrypto 策略中控台</title>

  <style>
    :root {
      --maxw: 1600px;
      --panel-h: 420px;
      --bg: #f6f7fb;
      --fg: #0b1220;
      --muted: #64748b;
      --card: rgba(255, 255, 255, 0.75);
      --card-solid: #ffffff;
      --card-border: rgba(148, 163, 184, 0.28);
      --accent: #2563eb;
      --accent-2: #06b6d4;
      --accent-soft: rgba(37, 99, 235, 0.12);
      --thead: rgba(248, 250, 252, 0.9);
      --row-alt: rgba(248, 250, 252, 0.7);
      --hover: rgba(219, 234, 254, 0.6);
      --ok-bg: #ecfdf3;
      --ok-bd: #22c55e;
      --err-bg: #fef2f2;
      --err-bd: #f97373;
    }
    body.dark {
      --bg: #020617;
      --fg: #e5e7eb;
      --muted: #94a3b8;
      --card: rgba(2, 6, 23, 0.72);
      --card-solid: #020617;
      --card-border: rgba(148, 163, 184, 0.22);
      --accent: #60a5fa;
      --accent-2: #22d3ee;
      --accent-soft: rgba(96, 165, 250, 0.12);
      --thead: rgba(2, 6, 23, 0.88);
      --row-alt: rgba(2, 6, 23, 0.55);
      --hover: rgba(30, 41, 59, 0.6);
    }

    html, body { height: 100%; }

    body {
      margin: 0;
      padding: 24px 32px 32px;
      background:
        radial-gradient(800px 520px at 15% 10%, rgba(37, 99, 235, 0.20), transparent 60%),
        radial-gradient(700px 520px at 85% 25%, rgba(6, 182, 212, 0.18), transparent 58%),
        radial-gradient(900px 650px at 35% 95%, rgba(34, 197, 94, 0.12), transparent 55%),
        linear-gradient(180deg, #f8fafc 0%, var(--bg) 60%);
      color: var(--fg);
      font-family: ui-sans-serif, system-ui, "Segoe UI", -apple-system,
        "Noto Sans TC", "PingFang TC", "Microsoft JhengHei";
    }
    body.dark {
      background:
        radial-gradient(900px 520px at 15% 10%, rgba(96, 165, 250, 0.18), transparent 62%),
        radial-gradient(780px 520px at 85% 20%, rgba(34, 211, 238, 0.16), transparent 60%),
        radial-gradient(1000px 650px at 35% 95%, rgba(34, 197, 94, 0.10), transparent 58%),
        linear-gradient(180deg, #020617 0%, #020617 100%);
    }

    .wrap {
      max-width: var(--maxw);
      margin: 0 auto;
    }

    @media (max-width: 900px) {
      body { padding: 18px 14px 22px; }
    }

    .topbar {
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 18px;
    }

    .main-grid {
      display: grid;
      grid-template-columns: 1.65fr 1fr;
      gap: 16px;
      align-items: start;
    }
    @media (max-width: 1100px) {
      .main-grid { grid-template-columns: 1fr; }
    }

    .panel-card {
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    .table-wrap {
      border-radius: 12px;
      overflow: auto;
      border: 1px solid var(--card-border);
      background: rgba(255, 255, 255, 0.30);
    }
    body.dark .table-wrap {
      background: rgba(2, 6, 23, 0.30);
    }
    .title {
      font-size: 26px;
      font-weight: 700;
      letter-spacing: 0.04em;
      display: flex;
      align-items: baseline;
      gap: 10px;
    }
    .title span.sub {
      font-size: 12px;
      font-weight: 500;
      color: var(--muted);
      padding: 2px 8px;
      border-radius: 9999px;
      background: var(--accent-soft);
    }
    body.dark .title span.sub {
      background: #0b1120;
      color: #9ca3af;
    }

    .toolbar {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .btn,
    select {
      padding: 8px 12px;
      border-radius: 9999px;
      border: 1px solid rgba(148, 163, 184, 0.40);
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: #f8fafc;
      cursor: pointer;
      font-size: 12px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      line-height: 1.2;
      transition: background 0.15s ease, box-shadow 0.15s ease, transform 0.05s ease;
      box-shadow: 0 14px 30px rgba(2, 6, 23, 0.18);
    }
    .btn.small {
      font-size: 11px;
      padding: 6px 10px;
      box-shadow: none;
    }
    .btn:hover:enabled {
      transform: translateY(-1px);
      box-shadow: 0 12px 26px rgba(15, 23, 42, 0.25);
      filter: brightness(1.05);
    }
    .btn:active:enabled {
      transform: translateY(0);
      box-shadow: 0 4px 10px rgba(15, 23, 42, 0.15);
    }
    .btn:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
      transform: none;
    }
    select {
      background: var(--card-solid);
      color: var(--fg);
      box-shadow: none;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 9999px;
      border: 1px solid var(--card-border);
      font-size: 11px;
      line-height: 1.2;
      background: var(--card);
      backdrop-filter: blur(10px);
      color: var(--muted);
    }
    #status {
      background: var(--err-bg);
      border-color: var(--err-bd);
      color: #b91c1c;
      font-weight: 500;
    }
    #status::before {
      content: "";
      width: 8px;
      height: 8px;
      border-radius: 9999px;
      background: #ef4444;
      box-shadow: 0 0 0 3px rgba(248, 113, 113, 0.2);
    }
    #status.ok {
      background: var(--ok-bg);
      border-color: var(--ok-bd);
      color: #15803d;
    }
    #status.ok::before {
      background: #22c55e;
      box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.2);
    }
    #lastRefresh {
      color: var(--muted);
      font-size: 11px;
    }

    .card {
      border-radius: 18px;
      background: var(--card);
      border: 1px solid var(--card-border);
      backdrop-filter: blur(14px);
      box-shadow:
        0 18px 40px rgba(2, 6, 23, 0.10),
        0 1px 0 rgba(255, 255, 255, 0.18);
      padding: 16px 18px 18px;
      margin: 12px 0 20px;
    }
    body.dark .card {
      box-shadow: 0 18px 42px rgba(0, 0, 0, 0.52);
    }

    .card-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.3);
    }
    .card-title {
      font-weight: 600;
      letter-spacing: 0.03em;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .card-title::before {
      content: "";
      width: 6px;
      height: 20px;
      border-radius: 9999px;
      background: linear-gradient(180deg, var(--accent), #22c55e);
    }

    .log-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      height: var(--panel-h);
      overflow: auto;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid var(--card-border);
      background: rgba(255, 255, 255, 0.45);
    }
    body.dark .log-list {
      background: rgba(2, 6, 23, 0.45);
    }
    .log-item {
      display: grid;
      grid-template-columns: 160px 1fr;
      gap: 8px 12px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(255, 255, 255, 0.65);
    }
    .log-item:hover {
      background: var(--hover);
    }
    body.dark .log-item {
      background: rgba(2, 6, 23, 0.65);
      border-color: rgba(148, 163, 184, 0.20);
    }
    @media (max-width: 640px) {
      .log-item {
        grid-template-columns: 1fr;
      }
    }
    .log-time {
      color: var(--muted);
      font-size: 11px;
      font-variant-numeric: tabular-nums;
    }
    .log-msg {
      text-align: left;
      font-size: 13px;
      line-height: 1.35;
      word-break: break-word;
    }
    .log-tags {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .tag {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      border-radius: 9999px;
      font-size: 11px;
      border: 1px solid var(--card-border);
      background: var(--accent-soft);
      color: var(--fg);
    }

    #tv_chart {
      width: 100%;
      height: var(--panel-h);
      border-radius: 12px;
      overflow: hidden;
    }

    table {
      border-collapse: separate;
      border-spacing: 0 10px;
      width: 100%;
      min-width: 1100px;
      border-radius: 12px;
      overflow: hidden;
      background: transparent;
    }

    /* Strategy list: render as modern cards inside the table */
    .table-wrap thead {
      display: none;
    }
    .table-wrap tbody tr.data-row td {
      background: transparent;
      border: 0;
      padding: 0;
    }
    .table-wrap tbody tr.data-row td:first-child::before {
      display: none;
    }

    .strategy-card {
      border-radius: 18px;
      border: 1px solid var(--card-border);
      background: var(--card);
      backdrop-filter: blur(14px);
      box-shadow:
        0 18px 40px rgba(2, 6, 23, 0.10),
        0 1px 0 rgba(255, 255, 255, 0.18);
      padding: 14px 14px 12px;
      display: flex;
      gap: 14px;
      justify-content: space-between;
      align-items: flex-start;
      position: relative;
      overflow: hidden;
      transition: transform 0.12s ease, filter 0.12s ease, box-shadow 0.15s ease;
    }
    body.dark .strategy-card {
      box-shadow: 0 18px 42px rgba(0, 0, 0, 0.52);
    }
    .strategy-card::before {
      content: "";
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 5px;
      background: linear-gradient(180deg, var(--accent), var(--accent-2));
    }
    .strategy-card:hover {
      transform: translateY(-1px);
      filter: brightness(1.02);
      box-shadow:
        0 22px 52px rgba(2, 6, 23, 0.16),
        0 1px 0 rgba(255, 255, 255, 0.18);
    }

    .strategy-main {
      flex: 1 1 auto;
      min-width: 0;
      padding-left: 6px;
    }
    .strategy-head {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .strategy-name {
      font-size: 15px;
      font-weight: 700;
      letter-spacing: 0.02em;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 520px;
    }
    @media (max-width: 900px) {
      .strategy-name { max-width: 100%; }
    }

    .strategy-sub {
      margin-top: 6px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .strategy-updated {
      font-size: 11px;
      color: var(--muted);
    }

    .strategy-updated.updated-active,
    .strategy-updated.updated-stale {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .strategy-updated.updated-active::before,
    .strategy-updated.updated-stale::before {
      content: "";
      width: 7px;
      height: 7px;
      border-radius: 9999px;
      background: currentColor;
      opacity: 0.9;
    }

    .kpi-grid {
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 10px;
    }
    @media (max-width: 900px) {
      .kpi-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }
    .kpi {
      border-radius: 14px;
      border: 1px solid var(--card-border);
      background: rgba(255, 255, 255, 0.45);
      padding: 10px 10px 9px;
    }
    body.dark .kpi {
      background: rgba(2, 6, 23, 0.35);
    }
    .kpi-label {
      font-size: 10px;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 4px;
    }
    .kpi-value {
      font-size: 15px;
      font-weight: 700;
      font-variant-numeric: tabular-nums;
      line-height: 1.1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .strategy-actions {
      flex: 0 0 auto;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 10px;
      padding-top: 2px;
    }

    .stale .strategy-card {
      filter: grayscale(0.25);
      opacity: 0.82;
    }

    thead th {
      position: sticky;
      top: 0;
      z-index: 1;
      background: var(--thead);
      backdrop-filter: blur(10px);
      color: var(--muted);
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      padding: 12px 10px;
      border-bottom: 1px solid var(--card-border);
    }

    th, td {
      border: 0;
      padding: 9px 10px;
      text-align: center;
      font-size: 13px;
    }

    tbody tr.data-row td {
      background: var(--card);
      border-top: 1px solid var(--card-border);
      border-bottom: 1px solid var(--card-border);
    }
    tbody tr.data-row td:first-child {
      border-left: 1px solid var(--card-border);
      border-top-left-radius: 12px;
      border-bottom-left-radius: 12px;
      position: relative;
      overflow: hidden;
      padding-left: 16px;
    }
    tbody tr.data-row td:last-child {
      border-right: 1px solid var(--card-border);
      border-top-right-radius: 12px;
      border-bottom-right-radius: 12px;
    }

    tbody tr.data-row td:first-child::before {
      content: "";
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      background: linear-gradient(180deg, var(--accent), var(--accent-2));
    }

    tbody tr.data-row {
      transition: transform 0.12s ease, filter 0.12s ease;
    }
    tbody tr.data-row:hover {
      transform: translateY(-1px);
      filter: brightness(1.02);
    }

    tbody td:first-child,
    tbody td:nth-child(2),
    tbody td:nth-child(3) {
      text-align: left;
    }

    td.num {
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    tbody tr.data-row:nth-of-type(odd) td {
      background: var(--row-alt);
    }
    tbody tr.data-row:hover td {
      background: var(--hover);
    }

    tbody tr.data-row.row-stale td {
      background: #f3f4f6;
    }
    tbody tr.data-row.row-stale:hover td {
      background: #e5e7eb;
    }
    body.dark tbody tr.data-row.row-stale td {
      background: #111827;
    }
    body.dark tbody tr.data-row.row-stale:hover td {
      background: #020617;
    }

    /* Desktop: KPI-style labels inside cells (more dashboard-like) */
    @media (min-width: 901px) {
      tbody tr.data-row td:nth-child(n+4):not(:last-child) {
        position: relative;
        padding-top: 22px;
      }
      tbody tr.data-row td:nth-child(n+4):not(:last-child)::before {
        content: attr(data-label);
        position: absolute;
        top: 6px;
        left: 10px;
        font-size: 10px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--muted);
        opacity: 0.9;
        pointer-events: none;
      }
      tbody tr.data-row td.num::before {
        left: auto;
        right: 10px;
        text-align: right;
      }
    }

    tr.chart-row { display: none; }
    tr.chart-row.open { display: table-row; }
    tr.chart-row > td {
      background: var(--card);
      border-top: 1px solid var(--card-border);
      border-bottom: 0;
      border-left: 0;
      border-right: 0;
      padding-top: 6px;
    }

    /* Mobile: stack each data row like a card */
    @media (max-width: 900px) {
      table {
        min-width: 0;
        border-spacing: 0 12px;
      }
      thead {
        display: none;
      }
      tbody tr.data-row {
        display: block;
      }
      tbody tr.data-row td {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 12px;
        text-align: right;
        padding: 10px 12px;
        border-left: 1px solid var(--card-border);
        border-right: 1px solid var(--card-border);
        border-top: 0;
        border-bottom: 1px solid var(--card-border);
      }
      tbody tr.data-row td:first-child {
        border-top: 1px solid var(--card-border);
        border-top-left-radius: 14px;
        border-top-right-radius: 14px;
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
      }
      tbody tr.data-row td:last-child {
        border-bottom-left-radius: 14px;
        border-bottom-right-radius: 14px;
        border-top-left-radius: 0;
        border-top-right-radius: 0;
      }
      tbody tr.data-row td::before {
        content: attr(data-label);
        color: var(--muted);
        font-size: 11px;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        text-align: left;
        flex: 0 0 auto;
      }
      tbody tr.data-row td.num {
        font-variant-numeric: tabular-nums;
      }
      tbody tr.data-row td:first-child {
        text-align: left;
      }
      tbody tr.data-row td:first-child::before {
        content: "名稱";
      }
      tr.chart-row.open {
        display: block;
      }
      tr.chart-row > td {
        display: block;
      }
    }

    .badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 2px 10px;
      border-radius: 9999px;
      font-size: 11px;
      line-height: 1.6;
      border: 1px solid var(--card-border);
      background: #f9fafb;
      color: #0f172a;
    }
    .badge.live {
      background: #ecfdf3;
      border-color: #4ade80;
      color: #166534;
    }
    .badge.paper {
      background: #eff6ff;
      border-color: #93c5fd;
      color: #1d4ed8;
    }
    .badge.backtest {
      background: #fff7ed;
      border-color: #fdba74;
      color: #9a3412;
    }
    body.dark .badge.live {
      background: #052e16;
      border-color: #22c55e;
      color: #bbf7d0;
    }
    body.dark .badge.paper {
      background: #0b1120;
      border-color: #60a5fa;
      color: #bfdbfe;
    }
    body.dark .badge.backtest {
      background: #3a2a10;
      border-color: #fb923c;
      color: #fed7aa;
    }

    .pct.pos { color: #16a34a; }
    .pct.neg { color: #ef4444; }
    .muted { color: var(--muted); }
    .dir-long {
      color: #22c55e;
      font-weight: 600;
    }
    .dir-short {
      color: #ef4444;
      font-weight: 600;
    }
    body.dark .dir-long {
      color: #4ade80;
    }
    body.dark .dir-short {
      color: #fca5a5;
    }

    .updated-active { color: #16a34a; font-weight: 500; }
    .updated-stale  { color: #f97316; }
    body.dark .updated-active { color: #4ade80; }
    body.dark .updated-stale  { color: #fdba74; }

    .inactive-pill {
      display: inline-flex;
      align-items: center;
      padding: 0 6px;
      border-radius: 9999px;
      border: 1px solid #d1d5db;
      font-size: 10px;
      margin-left: 4px;
      color: #6b7280;
      background: #f9fafb;
    }
    body.dark .inactive-pill {
      border-color: #374151;
      background: #020617;
      color: #9ca3af;
    }

    .chart-wrap {
      padding: 8px 4px 4px;
    }
    .chart-title {
      text-align: left;
      font-weight: 600;
      margin-bottom: 6px;
      font-size: 13px;
    }
    .chart-meta {
      text-align: left;
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    .chart-canvas {
      width: 100%;
      height: 320px;
    }
  </style>

  <script src="https://s3.tradingview.com/tv.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="./upstash-config.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        Qrypto 策略中控台
        <span class="sub">BTC 量化策略監控</span>
      </div>
      <div class="toolbar">
        <span id="status" class="chip" aria-live="polite">初始化</span>
        <span id="lastRefresh" class="chip">—</span>
        <button id="themeToggle" class="btn" type="button" title="切換明/暗">切換淺色</button>
      </div>
    </div>

    <div class="main-grid" aria-label="主儀表板">
      <div>
        <div class="card panel-card" aria-label="TradingView BTC K線">
          <div class="card-head">
            <div class="card-title">BTC/USDT K 線（TradingView）</div>
            <div class="toolbar">
              <label for="tv_symbol">幣種：</label>
              <select id="tv_symbol" title="選擇幣種">
                <option value="BTC" selected>BTC</option>
                <option value="ETH">ETH</option>
                <option value="SOL">SOL</option>
              </select>

              <label for="tv_tf" style="margin-left:8px;">時間週期：</label>
              <select id="tv_tf" title="選擇時間週期">
                <option value="1">1m</option>
                <option value="5">5m</option>
                <option value="15" selected>15m</option>
                <option value="60">1h</option>
                <option value="240">4h</option>
                <option value="D">1d</option>
              </select>
            </div>
          </div>
          <div id="tv_chart"></div>
        </div>
      </div>

      <div>
        <div class="card panel-card" aria-label="交易訊息">
          <div class="card-head">
            <div class="card-title">交易訊息</div>
            <div class="toolbar">
              <span id="feedStatus" class="chip">—</span>
            </div>
          </div>
          <div id="feedList" class="log-list" role="log" aria-live="polite">
            <div class="muted">載入中…</div>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-head">
        <div class="card-title">策略列表</div>
        <div class="toolbar">
          <span class="muted">資料來源：Upstash（自動探索 board:*）</span>

          <label for="yearFilter" class="muted">年度：</label>
          <select id="yearFilter" title="切換統計年度">
            <option value="">載入中…</option>
          </select>

          <button id="toggleInactive" class="btn small" type="button" disabled>
            無不活躍策略
          </button>
        </div>
      </div>
      <div class="table-wrap">
        <table aria-label="策略清單">
          <thead>
            <tr>
              <th style="width:160px;">名稱</th>
              <th>策略</th>
              <th>標的</th>
              <th>運行模式</th>
              <th>交易所</th>
              <th>槓桿</th>
              <th>方向</th>
              <th>7天收益率</th>
              <th>30天收益率</th>
              <th>線性年化報酬率<br>(依據總收益)</th>
              <th>最大回撤</th>
              <th>起始時間</th>
              <th>更新時間</th>
              <th style="width:110px;">回測圖表</th>
            </tr>
          </thead>
          <tbody id="tb">
            <tr><td class="muted" colspan="14">資料載入中…</td></tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <script>
    let tvWidget = null;

    // 取得目前選中的幣種（BTC / ETH / SOL，預設 BTC）
    function getCurrentAssetBase() {
      const sel = document.getElementById('tv_symbol');
      const val = sel && sel.value ? sel.value.toUpperCase() : 'BTC';
      if (val !== 'BTC' && val !== 'ETH' && val !== 'SOL') return 'BTC';
      return val;
    }

    // 根據幣種更新頁面上的文字（副標題、TradingView 卡片標題等）
    function updateSymbolTexts() {
      const base = getCurrentAssetBase();

      // 左上角小標
      const sub = document.querySelector('.title span.sub');
      if (sub) {
        sub.textContent = `${base} 量化策略監控`;
      }

      // TradingView 卡片 aria-label 與標題
      const tvCard = document.querySelector('.card[aria-label^="TradingView"]');
      if (tvCard) {
        tvCard.setAttribute('aria-label', `TradingView ${base} K線`);
        const titleEl = tvCard.querySelector('.card-title');
        if (titleEl) {
          titleEl.textContent = `${base}/USDT K 線（TradingView）`;
        }
      }
    }

    (function setupTheme() {
      const btn = document.getElementById('themeToggle');
      function applyTheme(theme) {
        const isDark = theme === 'dark';
        document.body.classList.toggle('dark', isDark);
        btn.textContent = isDark ? '切換淺色' : '切換深色';
        if (typeof window.__rerenderOpenCharts === 'function') window.__rerenderOpenCharts();
        recreateTVWidget();
      }
      btn.addEventListener('click', () => {
        const next = document.body.classList.contains('dark') ? 'light' : 'dark';
        applyTheme(next);
      });
      applyTheme('dark');
      window.__applyTheme = applyTheme;
    })();

    function recreateTVWidget() {
      const container = document.getElementById('tv_chart');
      if (!window.TradingView || !container) return;

      const base = getCurrentAssetBase();   // BTC / ETH / SOL
      const symbolCode = `BINANCE:${base}USDT`;

      container.innerHTML = '';
      tvWidget = new TradingView.widget({
        container_id: 'tv_chart',
        autosize: true,
        symbol: symbolCode,
        interval: document.getElementById('tv_tf')?.value || '15',
        timezone: 'Asia/Taipei',
        locale: 'zh_TW',
        theme: document.body.classList.contains('dark') ? 'dark' : 'light',
        style: '1',
        withdateranges: true,
        hide_top_toolbar: false,
        hide_side_toolbar: false,
        allow_symbol_change: false,
        details: true,
        enable_publishing: false
      });
    }

    window.addEventListener('DOMContentLoaded', function () {
      if (!window.TradingView) { console.error('[TradingView] Script 未載入'); return; }

      recreateTVWidget();

      const tfSel = document.getElementById('tv_tf');
      tfSel.addEventListener('change', function () {
        const val = tfSel.value;
        tvWidget && tvWidget.onChartReady(function () {
          tvWidget.chart().setResolution(val, function(){});
        });
      });

      // 幣種切換：重建 TradingView + 更新文字 + 重畫打開中的回測圖
      const symbolSel = document.getElementById('tv_symbol');
      if (symbolSel) {
        symbolSel.addEventListener('change', function () {
          recreateTVWidget();
          updateSymbolTexts();
          if (typeof window.__rerenderOpenCharts === 'function') {
            window.__rerenderOpenCharts();
          }
        });
      }

      if (typeof window.__applyTheme === 'function') {
        const current = document.body.classList.contains('dark') ? 'dark' : 'light';
        window.__applyTheme(current);
      }

      // 初始化文字（依據預設幣種）
      updateSymbolTexts();
    });

    const REST_URL = window.UPSTASH_REST_URL;
    const READ_TOKEN = window.UPSTASH_READ_TOKEN;
    const INTERVAL_MS = window.QRYPTO_PULL_INTERVAL_MS ?? 600000;

    // 交易/進場訊息（從 Upstash 讀取 List：LRANGE）
    // 建議演算法端用 LPUSH + LTRIM 維持最新 N 筆
    const FEED_LIST_KEY = window.QRYPTO_FEED_LIST_KEY ?? "log:events";
    const FEED_LIMIT = window.QRYPTO_FEED_LIMIT ?? 80;
    const FEED_POLL_MS = window.QRYPTO_FEED_POLL_MS ?? 5000;

    const tb = document.getElementById("tb");
    const statusEl = document.getElementById("status");
    const lastRefreshEl = document.getElementById("lastRefresh");
    const inactiveToggleBtn = document.getElementById("toggleInactive");
    const yearFilterSel = document.getElementById("yearFilter");

    const feedListEl = document.getElementById("feedList");
    const feedStatusEl = document.getElementById("feedStatus");

    const chartInstances = new Map();
    const chartSeriesCache = new Map();
    const normalizedSeriesCache = new Map();
    const yearsByBoard = new Map();
    let allYearsSet = new Set();

    let showInactive = true;
    let yearFilterValue = null;

    let latestRowsByKey = null;
    let latestSeriesKeyByBoard = null;
    let latestSortedBoardKeys = null;

    function setStatus(ok, text) {
      statusEl.className = ok ? "chip ok" : "chip";
      statusEl.textContent = text;
    }

    function fmtPercentNode(x) {
      const span = document.createElement("span");
      const n = Number(x);
      if (!isFinite(n)) {
        span.className = "pct";
        span.textContent = "-";
        return span;
      }
      const val = n * 100;
      span.textContent = val.toFixed(2) + "%";
      span.className = val > 0 ? "pct pos" : (val < 0 ? "pct neg" : "pct");
      return span;
    }

    function fmtPercentText(x) {
      const n = Number(x);
      if (!isFinite(n)) return "-";
      const val = n * 100;
      return val.toFixed(2) + "%";
    }

    function textNode(s) {
      const span = document.createElement("span");
      span.textContent = (s ?? "-");
      return span;
    }

    function fmtISOToTPE(iso) {
      if (typeof iso !== "string" || !iso) return "-";
      const d = new Date(iso);
      if (isNaN(d.getTime())) return iso;
      const f = new Intl.DateTimeFormat("zh-Hant", {
        timeZone: "Asia/Taipei",
        year: "numeric", month: "2-digit", day: "2-digit",
        hour: "2-digit", minute: "2-digit",
        hour12: false
      });
      return f.format(d);
    }

    function fmtISOToTPEDate(iso) {
      if (typeof iso !== "string" || !iso) return "-";
      const d = new Date(iso);
      if (isNaN(d.getTime())) return iso;
      const f = new Intl.DateTimeFormat("zh-Hant", {
        timeZone: "Asia/Taipei",
        year: "numeric", month: "2-digit", day: "2-digit"
      });
      return f.format(d);
    }

    function isRecentUpdate(iso) {
      if (typeof iso !== "string" || !iso) return false;
      const d = new Date(iso);
      if (isNaN(d.getTime())) return false;
      const diff = Date.now() - d.getTime();
      const sevenDaysMs = 7 * 24 * 60 * 60 * 1000;
      return diff <= sevenDaysMs;
    }

    function decodeVenue(venueStr) {
      if (typeof venueStr !== "string" || !venueStr) return { exchange: "-", env: "-" };
      const parts = venueStr.split(".");
      const exchange = parts[0] || "-";
      const envRaw = parts[1] || "mainnet";
      const env = envRaw.toLowerCase() === "testnet" ? "測試網" : "主網";
      return { exchange, env };
    }

    function fmtLeverage(val) {
      if (val === null || val === undefined || val === "") return "-";
      const n = Number(val);
      if (!isFinite(n)) return "-";
      return String(Math.round(n));
    }

    function fmtDirection(dir) {
      const s = String(dir || "").toLowerCase();
      if (!s) return "-";
      if (s === "long") return "Long";
      if (s === "short") return "Short";
      return dir;
    }

    function modeBadge(mode) {
      const m = String(mode || "").toLowerCase();
      const map = {
        live: "個人實盤",
        "server.live": "伺服實盤",
        paper: "模擬",
        backtest: "回測"
      };
      const span = document.createElement("span");
      let cls = m || "default";
      if (m === "server.live") cls = "live";
      span.className = "badge " + cls;
      span.textContent = map[m] || m || "-";
      return span;
    }

    function tdNode(child, className, label) {
      const td = document.createElement("td");
      if (className) td.className = className;
      if (label) td.setAttribute("data-label", label);
      td.appendChild(child);
      return td;
    }

    async function upstashGet(pathWithArgs) {
      if (!REST_URL || !READ_TOKEN) {
        throw new Error("Upstash 設定缺失：請確認 upstash-config.js 已載入（UPSTASH_REST_URL / UPSTASH_READ_TOKEN）");
      }
      const url = `${REST_URL}/${pathWithArgs}`;
      const res = await fetch(url, {
        headers: { "Authorization": `Bearer ${READ_TOKEN}` },
        cache: "no-store"
      });
      if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
      return res.json();
    }

    async function upstashLRange(key, start, stop) {
      const j = await upstashGet(
        `lrange/${encodeURIComponent(key)}/${start}/${stop}`
      );
      if (!j || !Array.isArray(j.result)) {
        throw new Error("LRANGE 回傳格式異常");
      }
      return j.result;
    }

    function safeParseJSON(s) {
      if (typeof s !== "string") return null;
      try {
        return JSON.parse(s);
      } catch {
        return null;
      }
    }

    function fmtFeedTime(x) {
      if (typeof x === "number" && isFinite(x)) {
        return new Date(x).toLocaleString("zh-TW", { hour12: false });
      }
      if (typeof x === "string" && x) {
        return fmtISOToTPE(x);
      }
      return "-";
    }

    function setFeedStatus(ok, text) {
      if (!feedStatusEl) return;
      feedStatusEl.className = ok ? "chip ok" : "chip";
      feedStatusEl.textContent = text;
    }

    function renderFeedItems(items) {
      if (!feedListEl) return;
      feedListEl.innerHTML = "";

      if (!items || items.length === 0) {
        const empty = document.createElement("div");
        empty.className = "muted";
        empty.textContent = "目前沒有訊息";
        feedListEl.appendChild(empty);
        return;
      }

      for (const it of items) {
        const wrap = document.createElement("div");
        wrap.className = "log-item";

        const t = document.createElement("div");
        t.className = "log-time";

        const msg = document.createElement("div");
        msg.className = "log-msg";

        const tags = document.createElement("div");
        tags.className = "log-tags";

        const obj = (typeof it === "object" && it) ? it : { msg: String(it) };
        const when = obj.ts ?? obj.time ?? obj.at;
        t.textContent = fmtFeedTime(when);

        const main = obj.msg ?? obj.message ?? obj.event ?? "(no message)";
        msg.textContent = String(main);

        const tagPairs = [
          ["strategy", obj.strategy],
          ["symbol", obj.symbol],
          ["side", obj.side],
          ["price", obj.price],
          ["qty", obj.qty],
          ["level", obj.level]
        ];
        for (const [k, v] of tagPairs) {
          if (v === null || v === undefined || v === "") continue;
          const tag = document.createElement("span");
          tag.className = "tag";
          tag.textContent = `${k}: ${v}`;
          tags.appendChild(tag);
        }

        wrap.appendChild(t);
        const right = document.createElement("div");
        right.appendChild(msg);
        if (tags.childNodes.length) right.appendChild(tags);
        wrap.appendChild(right);

        feedListEl.appendChild(wrap);
      }
    }

    async function pullFeed() {
      try {
        setFeedStatus(false, "訊息同步中…");

        const raw = await upstashLRange(FEED_LIST_KEY, 0, FEED_LIMIT - 1);
        const parsed = raw.map(s => {
          const obj = safeParseJSON(s);
          return obj ?? s;
        });

        renderFeedItems(parsed);
        setFeedStatus(true, `訊息 ${parsed.length}`);
      } catch (e) {
        console.warn("[feed 讀取失敗]", e);
        if (feedListEl) {
          feedListEl.innerHTML = "";
          const div = document.createElement("div");
          div.className = "muted";
          div.textContent = "訊息讀取失敗（請檢查 Upstash / 權限 / 網路）";
          feedListEl.appendChild(div);
        }
        setFeedStatus(false, "訊息失敗");
      }
    }

    async function scanBoardKeys(match = "board:*", pageCount = 200) {
      let cursor = "0";
      const all = [];
      do {
        const j = await upstashGet(
          `scan/${cursor}?MATCH=${encodeURIComponent(match)}&COUNT=${pageCount}`
        );
        if (!j || !Array.isArray(j.result) || j.result.length !== 2) {
          throw new Error("SCAN 回傳格式異常");
        }
        cursor = String(j.result[0]);
        const batch = j.result[1];
        if (Array.isArray(batch)) {
          for (const k of batch) if (typeof k === "string") all.push(k);
        }
      } while (cursor !== "0");
      return all;
    }

    async function fetchKeyJSON(key) {
      const j = await upstashGet(`get/${encodeURIComponent(key)}`);
      if (!j || typeof j.result !== "string") throw new Error("GET 回傳格式異常");
      let row;
      try {
        row = JSON.parse(j.result);
      } catch {
        throw new Error("JSON 解析失敗");
      }
      if (typeof row !== "object" || !row) throw new Error("資料內容不正確");
      return row;
    }

    async function fetchSeriesJSON(seriesKey) {
      const j = await upstashGet(`get/${encodeURIComponent(seriesKey)}`);
      if (!j || typeof j.result !== "string") throw new Error("GET 回傳格式異常");
      let arr;
      try {
        arr = JSON.parse(j.result);
      } catch {
        throw new Error("JSON 解析失敗");
      }
      if (!Array.isArray(arr)) throw new Error("序列資料型態錯誤");
      return arr;
    }

    async function resolveSeriesForBoard(boardKey, rowObj) {
      if (rowObj && typeof rowObj.series_key === "string" && rowObj.series_key) {
        return {
          key: rowObj.series_key,
          available: true,
          data: await fetchSeriesJSON(rowObj.series_key)
        };
      }
      const custom = String(boardKey).slice("board:".length);
      const candidates = [`series:${custom}:equity`, `series:${custom}:equity30d`];
      for (const sKey of candidates) {
        try {
          const data = await fetchSeriesJSON(sKey);
          return { key: sKey, available: true, data };
        } catch (_) {}
      }
      return { key: `series:${custom}:equity`, available: false, data: [] };
    }

    function renderChartInto(boardKey, canvas, series) {
      const ctx = canvas.getContext("2d");
      const isDark = document.body.classList.contains('dark');

      if (chartInstances.has(boardKey)) {
        chartInstances.get(boardKey).destroy();
        chartInstances.delete(boardKey);
      }
      if (!Array.isArray(series) || series.length === 0) return;

      const sample = series.find(x => x && typeof x === "object") || {};
      const base = getCurrentAssetBase();
      const keyMap = { BTC: "btc_close", ETH: "eth_close", SOL: "sol_close" };
      let priceKey = keyMap[base];

      // 如果沒有對應幣種欄位，就退回原本的自動偵測
      if (!priceKey || !Object.prototype.hasOwnProperty.call(sample, priceKey)) {
        const hasEth = Object.prototype.hasOwnProperty.call(sample, "eth_close");
        const hasBtc = Object.prototype.hasOwnProperty.call(sample, "btc_close");
        const hasSol = Object.prototype.hasOwnProperty.call(sample, "sol_close");
        if (hasBtc) priceKey = "btc_close";
        else if (hasEth) priceKey = "eth_close";
        else if (hasSol) priceKey = "sol_close";
        else priceKey = null;
      }

      let assetLabel = "Asset";
      if (priceKey === "btc_close") assetLabel = "BTC";
      else if (priceKey === "eth_close") assetLabel = "ETH";
      else if (priceKey === "sol_close") assetLabel = "SOL";

      const labels = series.map(x => String(x.date));
      const equity  = series.map(x => Number(x.equity));
      const price   = priceKey ? series.map(x => Number(x[priceKey])) : [];

      const chart = new Chart(ctx, {
        type: "line",
        data: {
          labels,
          datasets: [
            {
              label: "Equity",
              data: equity,
              yAxisID: "yEquity",
              tension: 0.25,
              pointRadius: 0,
              borderWidth: 2
            },
            {
              label: assetLabel + " Close",
              data: price,
              yAxisID: "yPrice",
              tension: 0.25,
              pointRadius: 0,
              borderWidth: 2
            }
          ]
        },
        options: {
          responsive: true,
          interaction: { mode: "index", intersect: false },
          plugins: {
            legend: {
              display: true,
              labels: { color: isDark ? "#e5e7eb" : "#0f172a" }
            },
            tooltip: {
              callbacks: {
                label: function(ctx) {
                  const ds = ctx.dataset.label || "";
                  const v = ctx.parsed.y;
                  return ds + ": " + (typeof v === "number" ? v.toLocaleString() : v);
                }
              }
            }
          },
          scales: {
            x: {
              ticks: {
                color: isDark ? "#cbd5e1" : "#334155",
                maxRotation: 0,
                autoSkip: true,
                maxTicksLimit: 10
              },
              grid: {
                color: isDark
                  ? "rgba(148,163,184,0.2)"
                  : "rgba(148,163,184,0.2)"
              }
            },
            yEquity: {
              type: "linear",
              position: "left",
              title: {
                display: true,
                text: "Equity",
                color: isDark ? "#e5e7eb" : "#0f172a"
              },
              ticks: { color: isDark ? "#cbd5e1" : "#334155" },
              grid: {
                color: isDark
                  ? "rgba(148,163,184,0.2)"
                  : "rgba(148,163,184,0.2)"
              }
            },
            yPrice: {
              type: "linear",
              position: "right",
              title: {
                display: true,
                text: assetLabel,
                color: isDark ? "#e5e7eb" : "#0f172a"
              },
              ticks: { color: isDark ? "#cbd5e1" : "#334155" },
              grid: {
                drawOnChartArea: false,
                color: isDark
                  ? "rgba(148,163,184,0.2)"
                  : "rgba(148,163,184,0.2)"
              }
            }
          }
        }
      });
      chartInstances.set(boardKey, chart);

      const wrap = canvas.closest(".chart-wrap");
      if (wrap) {
        const titleEl = wrap.querySelector(".chart-title");
        const metaEl  = wrap.querySelector(".chart-meta");
        if (titleEl) {
          titleEl.textContent = titleEl.textContent.replace(
            /資金曲線與.*收盤/,
            `資金曲線與 ${assetLabel} 收盤`
          );
        }
        if (metaEl) {
          const old = metaEl.textContent || "";
          const info = priceKey
            ? `（price: ${priceKey}）`
            : `（price: 無對應欄位）`;
          if (!/（price:/.test(old)) metaEl.textContent = `${old} ${info}`.trim();
        }
      }
    }

    window.__rerenderOpenCharts = function() {
      for (const [boardKey] of chartInstances.entries()) {
        const canvas = document.getElementById(`canvas-${boardKey.replace(":","-")}`);
        if (!canvas) continue;
        const tr = canvas.closest('tr.chart-row');
        if (!tr || !tr.classList.contains('open')) continue;
        const series = chartSeriesCache.get(boardKey) || [];
        renderChartInto(boardKey, canvas, series);
      }
    };

    function updateInactiveToggleLabel(count) {
      if (!inactiveToggleBtn) return;
      inactiveToggleBtn.dataset.inactiveCount = String(count);
      if (count === 0) {
        inactiveToggleBtn.textContent = "無不活躍策略";
        inactiveToggleBtn.disabled = true;
        return;
      }
      inactiveToggleBtn.disabled = false;
      inactiveToggleBtn.textContent = showInactive
        ? `隱藏不活躍策略 (${count})`
        : `顯示不活躍策略 (${count})`;
    }

    function applyInactiveVisibility() {
      const rows = tb.querySelectorAll("tr.data-row.row-stale");
      rows.forEach(tr => {
        tr.style.display = showInactive ? "" : "none";
      });
    }

    if (inactiveToggleBtn) {
      inactiveToggleBtn.addEventListener("click", () => {
        showInactive = !showInactive;
        const count = Number(inactiveToggleBtn.dataset.inactiveCount || "0");
        updateInactiveToggleLabel(count);
        applyInactiveVisibility();
      });
    }

    // 將整條資金曲線整理成「時間排序、含年度」的陣列
    function buildNormalizedSeries(series) {
      const arr = [];
      if (!Array.isArray(series)) return arr;
      for (const s of series) {
        if (!s) continue;
        const d = new Date(s.date);
        const t = d.getTime();
        if (!isFinite(t)) continue;
        const year = d.getFullYear();
        const eq = Number(s.equity);
        if (!isFinite(eq)) continue;
        arr.push({ t, year, equity: eq });
      }
      arr.sort((a, b) => a.t - b.t);
      return arr;
    }

    // 針對指定年度計算：7d, 30d, 年化, 最大回撤, 總報酬
    function computeYearStats(normalizedSeries, year) {
      if (!normalizedSeries || !normalizedSeries.length) return null;
      const Y = Number(year);
      if (!isFinite(Y)) return null;

      const subset = normalizedSeries.filter(p => p.year === Y);
      if (!subset.length) return null;

      const first = subset[0];
      const last  = subset[subset.length - 1];

      const startEq = first.equity;
      const endEq   = last.equity;
      let totalReturn = NaN;
      if (isFinite(startEq) && startEq > 0 && isFinite(endEq)) {
        totalReturn = (endEq / startEq) - 1;
      }

      const msDiff = last.t - first.t;
      const dayDiff = (msDiff / 86400000) + 1;
      let annualizedReturn = NaN;
      if (isFinite(totalReturn) && dayDiff > 0) {
        annualizedReturn = totalReturn * 365 / dayDiff;
      }

      let peak = subset[0].equity;
      let maxDD = 0;
      for (const p of subset) {
        if (p.equity > peak) peak = p.equity;
        if (peak > 0) {
          const dd = (p.equity / peak) - 1;
          if (dd < maxDD) maxDD = dd;
        }
      }

      function calcLookback(days) {
        const targetTs = last.t - days * 86400000;
        let base = null;
        for (let i = subset.length - 1; i >= 0; i--) {
          if (subset[i].t <= targetTs) { base = subset[i]; break; }
        }
        if (!base || base.equity <= 0) {
          return (last.equity / subset[0].equity) - 1;
        }
        return (last.equity / base.equity) - 1;
      }

      const r7  = calcLookback(7);
      const r30 = calcLookback(30);

      return {
        totalReturn,
        annualizedReturn: totalReturn < 0 ? totalReturn : annualizedReturn,
        maxDrawdown: maxDD,
        return7d: r7,
        return30d: r30
      };
    }

    function rebuildYearFilterOptions(yearsArr) {
      if (!yearFilterSel) return;

      yearFilterSel.innerHTML = "";

      if (!yearsArr || yearsArr.length === 0) {
        const op = document.createElement("option");
        op.value = "";
        op.textContent = "無資料";
        yearFilterSel.appendChild(op);
        yearFilterSel.disabled = true;
        yearFilterValue = null;
        return;
      }

      const sorted = yearsArr.slice().sort((a, b) => b - a);

      sorted.forEach(y => {
        const op = document.createElement("option");
        op.value = String(y);
        op.textContent = String(y);
        yearFilterSel.appendChild(op);
      });

      const prev = yearFilterValue ? Number(yearFilterValue) : null;
      if (!prev || !sorted.includes(prev)) {
        yearFilterValue = String(sorted[0]); // 預設最新年度
      }
      yearFilterSel.value = yearFilterValue;
      yearFilterSel.disabled = false;
    }

    if (yearFilterSel) {
      yearFilterSel.addEventListener("change", () => {
        yearFilterValue = yearFilterSel.value || null;
        if (latestRowsByKey && latestSeriesKeyByBoard && latestSortedBoardKeys) {
          renderTable(latestRowsByKey, latestSeriesKeyByBoard, latestSortedBoardKeys);
        }
      });
    }

    function renderTable(rowsByKey, seriesKeyByBoard, sortedBoardKeys) {
      tb.innerHTML = "";
      if (!sortedBoardKeys || sortedBoardKeys.length === 0) {
        const tr = document.createElement("tr");
        tr.className = "data-row";
        const td = document.createElement("td");
        td.colSpan = 14;
        td.className = "muted";
        td.textContent = "目前未發現可用的策略資料（board:*）。";
        tr.appendChild(td);
        tb.appendChild(tr);
        updateInactiveToggleLabel(0);
        return;
      }

      let inactiveCount = 0;
      const yearNum = yearFilterValue ? Number(yearFilterValue) : null;

      for (const key of sortedBoardKeys) {
        const row = rowsByKey.get(key);
        if (!row) continue;

        const sKey = seriesKeyByBoard.get(key);
        const norm = normalizedSeriesCache.get(key) || [];
        const yearsSet = yearsByBoard.get(key);

        let yearStats = null;

        if (yearNum !== null) {
          if (!yearsSet || !yearsSet.has(yearNum)) {
            continue; // 該策略這個年度沒有任何資料 → 不顯示
          }
          yearStats = computeYearStats(norm, yearNum);
        }

        const { exchange, env } = decodeVenue(row.venue);

        const tr = document.createElement("tr");
        tr.className = "data-row";

        const recent = isRecentUpdate(row.updated_at);
        if (!recent) {
          tr.classList.add("row-stale", "stale");
          inactiveCount++;
        }

        const td = document.createElement("td");
        td.colSpan = 14;

        const card = document.createElement("div");
        card.className = "strategy-card";

        const main = document.createElement("div");
        main.className = "strategy-main";

        const head = document.createElement("div");
        head.className = "strategy-head";

        const name = document.createElement("div");
        name.className = "strategy-name";
        name.textContent = row.name || key;
        head.appendChild(name);

        if (yearNum !== null) {
          const y = document.createElement("span");
          y.className = "badge backtest";
          y.textContent = `${yearNum} 統計`;
          head.appendChild(y);
        }

        head.appendChild(modeBadge(row.run_mode));

        const dirText = fmtDirection(row.direction);
        if (dirText && dirText !== "-") {
          const dir = document.createElement("span");
          dir.textContent = dirText;
          dir.className = dirText === "Long" ? "tag dir-long" : (dirText === "Short" ? "tag dir-short" : "tag");
          head.appendChild(dir);
        }

        main.appendChild(head);

        const sub = document.createElement("div");
        sub.className = "strategy-sub";

        const updatedStr = fmtISOToTPE(row.updated_at);
        const updated = document.createElement("span");
        updated.className = "strategy-updated " + (recent ? "updated-active" : "updated-stale");
        updated.textContent = `更新：${updatedStr}`;
        updated.title = recent
          ? "最近 7 天內有更新（視為活躍策略）"
          : "已超過 7 天未更新（視為不活躍策略）";
        sub.appendChild(updated);

        if (!recent) {
          const pill = document.createElement("span");
          pill.className = "inactive-pill";
          pill.textContent = "不活躍";
          sub.appendChild(pill);
        }

        const chips = [
          ["策略", row.strategy],
          ["標的", row.symbol],
          ["交易所", exchange],
          ["環境", env],
          ["槓桿", fmtLeverage(row.leverage)],
          ["起始", fmtISOToTPEDate(row.started_at)],
        ];
        for (const [k, v] of chips) {
          if (v === null || v === undefined || v === "" || v === "-") continue;
          const tag = document.createElement("span");
          tag.className = "tag";
          tag.textContent = `${k}: ${v}`;
          sub.appendChild(tag);
        }
        main.appendChild(sub);

        const r7Val  = yearStats ? yearStats.return7d        : row.return_7d;
        const r30Val = yearStats ? yearStats.return30d       : row.return_30d;
        const annVal = yearStats ? yearStats.annualizedReturn: row.annualized_return;
        const totVal = yearStats ? yearStats.totalReturn     : row.return_total;
        const ddVal  = yearStats ? yearStats.maxDrawdown     : row.max_drawdown;

        const grid = document.createElement("div");
        grid.className = "kpi-grid";

        function kpi(label, valueNode, title) {
          const box = document.createElement("div");
          box.className = "kpi";
          if (title) box.title = title;
          const l = document.createElement("div");
          l.className = "kpi-label";
          l.textContent = label;
          const v = document.createElement("div");
          v.className = "kpi-value";
          v.appendChild(valueNode);
          box.appendChild(l);
          box.appendChild(v);
          return box;
        }

        const totalText = fmtPercentText(totVal);
        grid.appendChild(kpi("總收益", fmtPercentNode(totVal), "從起始資金到目前的總收益率"));
        grid.appendChild(kpi("30天", fmtPercentNode(r30Val), "最近 30 天的收益率"));

        const annTitle = totalText === "-"
          ? "年化(線性)：資料不足（會以總收益率替代顯示）"
          : `年化(線性)：依據總收益率 ${totalText}`;
        grid.appendChild(kpi("年化(線性)", fmtPercentNode(annVal), annTitle));
        grid.appendChild(kpi("最大回撤", fmtPercentNode(ddVal), "回測/序列期間的最大回撤"));
        main.appendChild(grid);

        const actions = document.createElement("div");
        actions.className = "strategy-actions";
        if (sKey) {
          const btn = document.createElement("button");
          btn.className = "btn small";
          btn.textContent = "查看曲線";
          btn.addEventListener("click", () => toggleChartRow(key));
          actions.appendChild(btn);
        } else {
          const no = document.createElement("span");
          no.className = "muted";
          no.textContent = "無曲線資料";
          actions.appendChild(no);
        }

        card.appendChild(main);
        card.appendChild(actions);
        td.appendChild(card);
        tr.appendChild(td);
        tb.appendChild(tr);

        if (sKey) {
          const trChart = document.createElement("tr");
          trChart.className = "chart-row";
          trChart.id = `chartrow-${key.replace(":","-")}`;
          const tdChart = document.createElement("td");
          tdChart.colSpan = 14;

          const wrap = document.createElement("div");
          wrap.className = "chart-wrap";

          const title = document.createElement("div");
          title.className = "chart-title";
          title.textContent = `${row.name || key} — 資金曲線與 收盤`;

          const meta = document.createElement("div");
          meta.className = "chart-meta";
          meta.textContent = `series: ${sKey}`;

          const canvas = document.createElement("canvas");
          canvas.className = "chart-canvas";
          canvas.id = `canvas-${key.replace(":","-")}`;

          wrap.appendChild(title);
          wrap.appendChild(meta);
          wrap.appendChild(canvas);
          tdChart.appendChild(wrap);
          trChart.appendChild(tdChart);
          tb.appendChild(trChart);
        }
      }

      updateInactiveToggleLabel(inactiveCount);
      applyInactiveVisibility();
    }

    function toggleChartRow(boardKey) {
      const rowId = boardKey.replace(":","-");
      const chartTr = document.getElementById(`chartrow-${rowId}`);
      if (!chartTr) return;

      if (chartTr.classList.contains('open')) {
        chartTr.classList.remove('open');
        return;
      }

      chartTr.classList.add('open');
      const canvas = chartTr.querySelector("canvas");
      const series = chartSeriesCache.get(boardKey) || [];
      renderChartInto(boardKey, canvas, series);
    }

    async function pullAll() {
      try {
        setStatus(false, "資料同步中…");

        const boardKeys = await scanBoardKeys("board:*", 200);

        const rowsByKey = new Map();
        const discovered = [];
        for (const k of boardKeys) {
          try {
            const row = await fetchKeyJSON(k);
            rowsByKey.set(k, row);
            const name = (row && row.name) ? String(row.name) : "";
            const updated = (row && row.updated_at)
              ? Date.parse(row.updated_at)
              : 0;
            discovered.push({ key: k, name, updated });
          } catch (e) {
            console.warn("[board 讀取失敗]", k, e);
          }
        }

        discovered.sort((a, b) => {
          if (!!a.name !== !!b.name) return b.name ? 1 : -1;
          if (a.updated !== b.updated) return b.updated - a.updated;
          return a.key.localeCompare(b.key);
        });
        const sortedBoardKeys = discovered.map(x => x.key);

        const seriesKeyByBoard = new Map();
        chartSeriesCache.clear();
        normalizedSeriesCache.clear();
        yearsByBoard.clear();
        allYearsSet = new Set();

        for (const k of sortedBoardKeys) {
          const row = rowsByKey.get(k);
          if (!row) continue;
          try {
            const { key: sKey, available, data } =
              await resolveSeriesForBoard(k, row);
            if (available) {
              seriesKeyByBoard.set(k, sKey);
              chartSeriesCache.set(k, data);

              const norm = buildNormalizedSeries(data);
              normalizedSeriesCache.set(k, norm);

              const yearSet = new Set();
              for (const p of norm) {
                yearSet.add(p.year);
                allYearsSet.add(p.year);
              }
              yearsByBoard.set(k, yearSet);
            }
          } catch (e) {
            console.warn("[series 探測失敗：視為無]", k, e);
          }
        }

        const yearArray = Array.from(allYearsSet);
        rebuildYearFilterOptions(yearArray);

        latestRowsByKey = rowsByKey;
        latestSeriesKeyByBoard = seriesKeyByBoard;
        latestSortedBoardKeys = sortedBoardKeys;

        renderTable(rowsByKey, seriesKeyByBoard, sortedBoardKeys);

        setStatus(true, "服務正常");
        lastRefreshEl.textContent = "最後更新：" +
          new Date().toLocaleString("zh-TW", { hour12:false });

      } catch (e) {
        console.error(e);
        setStatus(false, "資料讀取失敗");
        tb.innerHTML = "";
        const tr = document.createElement("tr");
        tr.className = "data-row";
        const td = document.createElement("td");
        td.colSpan = 14;
        td.className = "muted";
        td.textContent = "目前無法取得資料，請稍後重新整理或檢查網路／權限設定。";
        tr.appendChild(td);
        tb.appendChild(tr);
        updateInactiveToggleLabel(0);
      }
    }

    pullAll();
    setInterval(pullAll, INTERVAL_MS);

    // 訊息面板輪詢（獨立於策略清單刷新）
    pullFeed();
    setInterval(pullFeed, FEED_POLL_MS);
  </script>
</body>
</html>
